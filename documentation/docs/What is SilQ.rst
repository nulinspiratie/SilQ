************
What is SilQ
************

SilQ is a measurement software developed in the group of Andrea Morello for
experiments on donors in silicon.
That being said, the code has been written with the goal of being generic enough
to be used in other systems (see `Can SilQ be used for our experiments? <can-silq-be-used-for-our-experiments>`).
To give a description of what SilQ is, a few words are first needed on QCoDeS,
which is the platform on which SilQ is built.

===============
What is QCoDeS?
===============
`QCoDeS <http://qcodes.github.io/Qcodes/>`_ is a Python-based data acquisition
framework developed by the Copenhagen / Delft / Sydney / Microsoft quantum
computing consortium.
It provides a common base for experiments on nanoelectronics and beyond.
Main features of the framework are

- Communication with a large assortment of instruments via drivers;
- Creating and executing measurement loops using instruments.
- Storage of data generated by measurements, including a snapshot of the current
  instruments
- Visualization of experimental data

These features are general enough that they are useful for a large range of
experiments, and they are the foundation of SilQ.
More information can be found on the website of `QCoDeS`_

=======================
Well then what is SilQ?
=======================

The problem
-----------
The features provided by QCoDeS allow easy execution of fairly simple experiments,
such as sweeping one or more voltages, and measuring a current.
However, as experiments become more and more complicated, layers of abstraction
are needed to manage the experimental complexity.

Pulse sequences are a clear example of where this is the case.
Programming a pulse sequence for an experiment usually requires interaction
between several instruments: precise triggering, outputting pulses in the right
order, with the right amplitude, frequency, and being able to measure the
resulting signal at the right time.
This can easily translate into over a hundred commands sent to different
instruments.
Without a modular programming approach, this can quickly become a mess, and
changing a single parameter in the pulse sequence can require major
modifications to the code.

The solution
------------
SilQ has been developed precisely to combat the increasing complexity of
experiments by building layers of abstraction.
The primary focus of SilQ is on pulse sequences.
Instead of worrying about instructions sent to instruments, the experimenter
focuses on the properties that the pulse sequence should have, and SilQ deals
with translating this into specific machine instructions.

To give a concrete example, SilQ lets an experimenter create a pulse sequence like::

    PulseSequence with 3 pulses, duration: 2
        DCPulse(DC_high, A=1, t_start=0, duration=1)
        SinePulse(AC, f=10 kHz, phase=0 deg (rel), A=1 V, t_start=0.5, duration=1.0)
        DCPulse(DC_low, A=-1, t_start=1, duration=1)

Notice that this pulse sequence only contains information about the pulses, and
not at all about the instruments in the setup, nor about any ancillary pulses,
such as trigger pulses.
The instruments and their connectivity are stored in SilQ, so SilQ can figure out
how to convert this pulse sequence to the appropriate instrument instructions,
such that the instruments will indeed output the correct pulse sequence.
Because the pulse sequence is agnostic to the experimental setup, the same
pulse sequence can be used for completely different setups. Exchanging an
instrument for another brand no longer needs a rewrite of the measurement code.

SilQ is based on QCoDeS, and so the full array of features from QCoDeS can be
used here. This includes creating measurement loops with pulse sequences,
storing the measurement data from pulse sequences.
One could imagine sweeping the frequency of the ``SinePulse`` above, and
measuring the resulting signal at the end.

SilQ also contains many other features, such as data analysis, tune-up sequences,
some of which are based on neural networks, and measurement-related Jupyter
Notebook widgets.
=============
PulseSequence
=============

The PulseSequence is a class that encompasses Pulses, and is able to define a
 measurement. Its current features are as follows:

Current features
================
- Ability to add/remove/address pulses
- Fixed total duration, determined from the pulses it contains
- Handle enabling/disabling of inidividual pulses
- Restrictions on adding (un)targeted pulses
- Find pulse(s) based on certain pulse or connection properties
- Find connection based on certain pulse or connection properties
- Check if pulses overlap
- Get transition voltage between two pulses (useful for triggering)


Desired features
================
That being said, it currently lacks some useful features, and
 is in need of an upgrade

Nesting PulseSequence within another PulseSequence
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The ability to nesting a PulseSequence in another PulseSequence allows a
natural way to break up a complex measurement into different layers.
For example, a PulseSequence could consists of three stages:

#. Initialization - Perform the necessary pulses to initialize the system
#. Manipulation - Manipulate the qubit through pulses
#. Read - Read out the state of the qubit

Each of these stages could be an independent PulseSequence, which are joined
together in the larger PulseSequence. If you combine this with the idea of
registering a PulseSequence in the config, it becomes especially useful. For
instance, the Read stage can be identical for different measurements, and so
you only have to program the Read PulseSequence once, and it can then be
called from all measurements.

Issues
******
One of the main issues is that targeting of a PulseSequence currently
targets individual pulses. Now instead a PulseSequence could consist of not
only Pulses, but also PulseSequences.

One solution is to roll-out the inner PulseSequences, effectively
concatenating their pulses together into one long PulseSequence. This can
become a problem when you combine it with logic operations, as these may
point towards an entire PulseSequence instead of a single pulse.

Another solution is to create an encompassing class, which itself
contains PulseSequences. You can then make the distinction that
PulseSequences have a fixed duration. Combining PulseSequences and
performing logic operations, such as conditional operations, can only be
implemented at the level of the encompassing class. However, this only shifts
the problem, as you could also want to join such encompassing classes together.

The actual problem may well be that the whole targeting process needs an
upgrade.

Implementation
**************
If we assume that targeting is taken care of, nesting PulseSequences should
have the following features:

- A name, which can be used to identify the PulseSequence when it is nested.
- The duration, if it exists. This may not be the case if the PulseSequence
  contains logic operations.
- Add a nested PulseSequences, just as you would add a pulse.
- **Optional** If a PulseSequence contains at least one PulseSequence, there
  should always be an active PulseSequence. If a Pulse is then added, it is
  automatically added to a PulseSequence. This way you ensure that a
  PulseSequence contains either Pulses or PulseSequences, but never both. One
  could even create a separate PulseSequence class for PulseSequences that
  contains other PulseSequences, although I'm not sure if its necessary.
- **Optional** Some sort of output data, which can be treated as input variables
  for other PulseSequences. This is related to logic operations.
- **Optional** Analysis within the PulseSequence. For instance, check for blips.

Loop over pulses
~~~~~~~~~~~~~~~~
There are situations where you want to loop over a pulse, or perhaps even over a
PulseSequence. An example is the CPMG sequence, which consists of many
identical pi pulses. Instead of having to add 8192 pi-pulses to a
PulseSequence, which can significantly slow down the measurement, it is much
easier to add a single pulse with a command to apply it a number of times.
This idea could be extended to also iteratively modifying an attribute of the
Pulse being looped.

Issues
******
- During targeting the loop should remain, i.e. the pulse should not be
  copied 8192 times.
- The duration of the PulseSequence should take the repetitions into account.

Implementation
**************
Perhaps the easiest way to implement this is to add a ``PulseSequence.repetitions``
attribute, equal to 1 by default. When you then want to
loop over one or more pulses, you wrap them in a PulseSequence and increase
the repetitions. In this case it would be necessary to also somehow pass
along the PulseSequence (which has information on ``repetitions``) during
targeting.

Another solution is to create logic that says: Go back to beginning of pulse
8192 times. However, this feels less elegant than the previous solution, also
since passing along logic can be complicated.

A third solution is to create a LoopPulse, which loops over a pulse. This
also seems less elegant than the first solution, mainly because it becomes
awkward to loop over a PulseSequence (a PulseSequence within a pulse?).

Look up PulseSequence from config
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
asd

Conditional pulses
~~~~~~~~~~~~~~~~~~

Add a label that defines PulseSequence properties
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
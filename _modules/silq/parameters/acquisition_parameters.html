

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>silq.parameters.acquisition_parameters &mdash; SilQ 1.0 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../../../_static/silq_icon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> SilQ
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../docs/What is SilQ.html">What is SilQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../docs/Installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../docs/Getting started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../docs/Brief QCoDeS guide.html">Brief QCoDeS guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../docs/Concepts in SilQ.html">Concepts in SilQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../docs/For developers.html">For developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../docs/in-depth guides/index.html">In-depth guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../specifications/index.html">Future work</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../docs/FAQ.html">Frequently asked questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../docs/Classes and functions index.html">Classes and functions index</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">SilQ</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../silq.html">silq</a> &raquo;</li>
        
      <li>silq.parameters.acquisition_parameters</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for silq.parameters.acquisition_parameters</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Sequence</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">OrderedDict</span><span class="p">,</span> <span class="n">Iterable</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">copy</span>
<span class="kn">from</span> <span class="nn">blinker</span> <span class="k">import</span> <span class="n">signal</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">partial</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="kn">from</span> <span class="nn">qcodes</span> <span class="k">import</span> <span class="n">DataSet</span><span class="p">,</span> <span class="n">MultiParameter</span><span class="p">,</span> <span class="n">active_dataset</span><span class="p">,</span> <span class="n">active_measurement</span><span class="p">,</span> \
    <span class="n">Parameter</span>
<span class="kn">from</span> <span class="nn">qcodes.data</span> <span class="k">import</span> <span class="n">hdf5_format</span>
<span class="kn">from</span> <span class="nn">qcodes</span> <span class="k">import</span> <span class="n">Instrument</span><span class="p">,</span> <span class="n">MatPlot</span>

<span class="kn">from</span> <span class="nn">silq</span> <span class="k">import</span> <span class="n">config</span>
<span class="kn">from</span> <span class="nn">silq.pulses</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">silq.pulses.pulse_sequences</span> <span class="k">import</span> <span class="n">ESRPulseSequence</span><span class="p">,</span> <span class="n">NMRPulseSequence</span><span class="p">,</span> \
    <span class="n">T2ElectronPulseSequence</span><span class="p">,</span> <span class="n">FlipFlopPulseSequence</span><span class="p">,</span> <span class="n">ESRRamseyDetuningPulseSequence</span>
<span class="kn">from</span> <span class="nn">silq.analysis</span> <span class="k">import</span> <span class="n">analysis</span>
<span class="kn">from</span> <span class="nn">silq.tools.general_tools</span> <span class="k">import</span> <span class="n">SettingsClass</span><span class="p">,</span> <span class="n">clear_single_settings</span><span class="p">,</span> \
    <span class="n">attribute_from_config</span><span class="p">,</span> <span class="n">UpdateDotDict</span><span class="p">,</span> <span class="n">convert_setpoints</span><span class="p">,</span> \
    <span class="n">property_ignore_setter</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;AcquisitionParameter&#39;</span><span class="p">,</span> <span class="s1">&#39;DCParameter&#39;</span><span class="p">,</span> <span class="s1">&#39;TraceParameter&#39;</span><span class="p">,</span>
           <span class="s1">&#39;DCSweepParameter&#39;</span><span class="p">,</span> <span class="s1">&#39;EPRParameter&#39;</span><span class="p">,</span> <span class="s1">&#39;ESRParameter&#39;</span><span class="p">,</span>
           <span class="s1">&#39;NMRParameter&#39;</span><span class="p">,</span> <span class="s1">&#39;VariableReadParameter&#39;</span><span class="p">,</span>
           <span class="s1">&#39;BlipsParameter&#39;</span><span class="p">,</span> <span class="s1">&#39;FlipNucleusParameter&#39;</span><span class="p">,</span> <span class="s1">&#39;FlipFlopParameter&#39;</span><span class="p">,</span>
           <span class="s1">&#39;NeuralNetworkParameter&#39;</span><span class="p">,</span> <span class="s1">&#39;NeuralRetuneParameter&#39;</span><span class="p">,</span><span class="s1">&#39;ESRRamseyDetuningParameter&#39;</span><span class="p">]</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">h5fmt</span> <span class="o">=</span> <span class="n">hdf5_format</span><span class="o">.</span><span class="n">HDF5Format</span><span class="p">()</span>


<div class="viewcode-block" id="AcquisitionParameter"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.AcquisitionParameter">[docs]</a><span class="k">class</span> <span class="nc">AcquisitionParameter</span><span class="p">(</span><span class="n">SettingsClass</span><span class="p">,</span> <span class="n">MultiParameter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parameter used for acquisitions involving a `PulseSequence`.</span>

<span class="sd">    Each AcquisitionParameter has an associated pulse sequence, which it directs</span>
<span class="sd">    to the Layout, after which it acquires traces and performs post-processing.</span>

<span class="sd">    Generally, the flow of an AcquisitionParameter is as follows:</span>

<span class="sd">    1. `AcquisitionParameter.acquire`, which acquires traces.</span>
<span class="sd">       This stage can be subdivided into several steps:</span>

<span class="sd">       1. Generate PulseSequence if pulse sequence properties have changed</span>
<span class="sd">          Note that this is only necessary for a `PulseSequenceGenerator`, which</span>
<span class="sd">          is a more complicated pulse sequences that can be generated from</span>
<span class="sd">          properties.</span>
<span class="sd">       2. Target pulse sequence in `Layout`.</span>
<span class="sd">          This only happens if `Layout.pulse_sequence` differs from the pulse</span>
<span class="sd">          sequence used.</span>
<span class="sd">       3. Call `Layout.setup` which sets up instruments with new pulse sequence.</span>
<span class="sd">          Again, this is only done if `Layout.pulse_sequence` differs.</span>
<span class="sd">       4. Acquire traces using `Layout.acquisition`</span>
<span class="sd">          This in turn gets the traces fromm the acquisition instrument.</span>
<span class="sd">          The returned traces are segmented by pulse and acquisition channel.</span>

<span class="sd">    2. `AcquisitionParameter.analyse`, which analyses the traces</span>
<span class="sd">       This method differs per AcquisitionParameter.</span>
<span class="sd">    3. Perform ancillary actions such as saving traces, printing results</span>
<span class="sd">    4. Return list of results for any measurement.</span>
<span class="sd">       The subset of results that are in ``AcquisitionParameter.names`` is</span>
<span class="sd">       returned.</span>

<span class="sd">    Args:</span>
<span class="sd">        continuous: If True, instruments keep running after acquisition</span>
<span class="sd">        properties_attrs: attributes to match with</span>
<span class="sd">            ``silq.config.properties`` (see notes below).</span>
<span class="sd">        save_traces: Save acquired traces to disk</span>
<span class="sd">        **kwargs: Additional kwargs passed to ``MultiParameter``</span>

<span class="sd">    Parameters:</span>
<span class="sd">        pulse_sequence (PulseSequence): Pulse sequence used for acquisition.</span>
<span class="sd">        samples (int): Number of acquisition samples</span>
<span class="sd">        results (dict): Results obtained after analysis of traces.</span>
<span class="sd">        traces (dict): Acquisition traces segmented by pulse and acquisition</span>
<span class="sd">            label</span>
<span class="sd">        silent (bool): Print results after acquisition</span>
<span class="sd">        continuous (bool): If True, instruments keep running after acquisition.</span>
<span class="sd">            Useful if stopping/starting instruments takes a considerable amount</span>
<span class="sd">            of time.</span>
<span class="sd">        properties_attrs (List[str]): Attributes to match with</span>
<span class="sd">            ``silq.config.properties`` See notes below for more info.</span>
<span class="sd">        save_traces (bool): Save acquired traces to disk.</span>
<span class="sd">            If the acquisition has been part of a measurement, the traces are</span>
<span class="sd">            stored in a subfolder of the corresponding data set.</span>
<span class="sd">            Otherwise, a new dataset is created.</span>
<span class="sd">        dataset (DataSet): Traces DataSet</span>
<span class="sd">        base_folder (str): Base folder in which to save traces. If not specified,</span>
<span class="sd">            and acquisition is part of a measurement, the base folder is the</span>
<span class="sd">            folder of the measurement data set. Otherwise, the base folder is</span>
<span class="sd">            the default data folder</span>
<span class="sd">        subfolder (str): Subfolder within the base folder to save traces.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - AcquisitionParameters are subclasses of the ``MultiParameter``, and</span>
<span class="sd">          therefore always returns multiple values</span>
<span class="sd">        - AcquisitionParameters are also subclasses of `SettingsClass`, which</span>
<span class="sd">          gives it the ability to temporarily override its attributes using</span>
<span class="sd">          methods `single_settings` and `temporary_settings`. These overridden</span>
<span class="sd">          settings can be clear later on. This is useful if you temporarily want</span>
<span class="sd">          to change settings. See `SettingsClass` for more info.</span>
<span class="sd">        - When certain elements in ``silq.config`` are updated, this will also</span>
<span class="sd">          update the corresponding attributes in the AcquisitionParameter.</span>
<span class="sd">          Two config paths are monitored:</span>

<span class="sd">          - ``silq.config.properties``, though only the attributes</span>
<span class="sd">            specified in ``properties_attrs``.</span>
<span class="sd">          - ``silq.parameters.{self.name}``.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">layout</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">formatter</span> <span class="o">=</span> <span class="n">h5fmt</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">continuous</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">properties_attrs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">wrap_set</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">save_traces</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">SettingsClass</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;pulse_sequence&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span> <span class="o">=</span> <span class="n">PulseSequence</span><span class="p">()</span>

        <span class="n">shapes</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;shapes&#39;</span><span class="p">,</span> <span class="p">((),</span> <span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;names&#39;</span><span class="p">]))</span>
        <span class="n">MultiParameter</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shapes</span><span class="o">=</span><span class="n">shapes</span><span class="p">,</span> <span class="n">wrap_set</span><span class="o">=</span><span class="n">wrap_set</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">layout</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">AcquisitionParameter</span><span class="o">.</span><span class="n">layout</span> <span class="o">=</span> <span class="n">Instrument</span><span class="o">.</span><span class="n">find_instrument</span><span class="p">(</span><span class="s1">&#39;layout&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;No layout found for </span><span class="si">{self}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">silent</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">save_traces</span> <span class="o">=</span> <span class="n">save_traces</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">continuous</span> <span class="o">=</span> <span class="n">continuous</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_folder</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subfolder</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Attach to properties and parameter configs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">properties_attrs</span> <span class="o">=</span> <span class="n">properties_attrs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">properties_config</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attach_to_config</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">f</span><span class="s1">&#39;properties&#39;</span><span class="p">,</span>
            <span class="n">select_attrs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">properties_attrs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameter_config</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attach_to_config</span><span class="p">(</span>
            <span class="n">path</span><span class="o">=</span><span class="n">f</span><span class="s1">&#39;parameters.</span><span class="si">{self.name}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_meta_attrs</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;pulse_sequence&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{self.name}</span><span class="s1"> acquisition parameter&#39;</span>

    <span class="k">def</span> <span class="nf">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">attribute_from_config</span><span class="p">(</span>
                <span class="n">item</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">properties</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="c1"># Update value in pulse settings if it exists</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">pulse_settings</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">pulse_settings</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="nd">@property_ignore_setter</span>
    <span class="k">def</span> <span class="nf">labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span> <span class="o">+</span> <span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sample_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Acquisition sample rate &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">layout</span><span class="o">.</span><span class="n">sample_rate</span>

<div class="viewcode-block" id="AcquisitionParameter.snapshot_base"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.AcquisitionParameter.snapshot_base">[docs]</a>    <span class="k">def</span> <span class="nf">snapshot_base</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">params_to_skip_update</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">simplify</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="n">snapshot</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">snapshot_base</span><span class="p">(</span><span class="n">update</span><span class="o">=</span><span class="n">update</span><span class="p">,</span>
                                         <span class="n">params_to_skip_update</span><span class="o">=</span><span class="n">params_to_skip_update</span><span class="p">,</span>
                                         <span class="n">simplify</span><span class="o">=</span><span class="n">simplify</span><span class="p">)</span>
        <span class="n">snapshot</span><span class="p">[</span><span class="s1">&#39;pulse_sequence&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">snapshot</span><span class="p">[</span><span class="s1">&#39;pulse_sequence&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">snapshot</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">snapshot</span></div>

    <span class="k">def</span> <span class="nf">_attach_to_config</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                          <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                          <span class="n">select_attrs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Attach parameter to a subconfig (within silq config).</span>

<span class="sd">        This means that whenever an item in the subconfig is updated,</span>
<span class="sd">        the parameter attribute will also be updated to this value.</span>

<span class="sd">        Notification of config updates is handled through blinker signals.</span>

<span class="sd">        After successfully attaching to a config, the parameter attributes</span>
<span class="sd">        that are present in the config are also updated.</span>

<span class="sd">        Args:</span>
<span class="sd">            path: subconfig path</span>
<span class="sd">            select_attrs: if specified, only update attributes in this list</span>

<span class="sd">        Returns:</span>
<span class="sd">            subconfig that the parameter is attached to</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO special handling of pulse_sequence attr, etc.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Get subconfig from silq config</span>
            <span class="n">subconfig</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="n">path</span><span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
            <span class="c1"># No subconfig exists, not attaching</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Get signal handling function</span>
        <span class="k">if</span> <span class="n">select_attrs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Only update attributes in select_attrs</span>
            <span class="n">signal_handler</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle_config_signal</span><span class="p">,</span>
                                     <span class="n">select</span><span class="o">=</span><span class="n">select_attrs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">signal_handler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle_config_signal</span>

        <span class="c1"># Connect changes in subconfig to handling function</span>
        <span class="n">signal</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;environment:</span><span class="si">{path}</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">signal_handler</span><span class="p">,</span> <span class="n">weak</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Set attributes that are present in subconfig</span>
        <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">subconfig</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">select_attrs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">select_attrs</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">subconfig</span>

    <span class="k">def</span> <span class="nf">_handle_config_signal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span>
                              <span class="n">select</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                              <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update attr when attr in pulse config is modified</span>

<span class="sd">        Args:</span>
<span class="sd">            _: sender config (unused)</span>
<span class="sd">            select: list of attrs that can be set.</span>
<span class="sd">                Will update any attribute if not specified.</span>
<span class="sd">            **kwargs: {attr: new_val}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">popitem</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">select</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">select</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

<div class="viewcode-block" id="AcquisitionParameter.setup"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.AcquisitionParameter.setup">[docs]</a>    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
              <span class="n">start</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
              <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Setup instruments with current pulse sequence.</span>

<span class="sd">        Args:</span>
<span class="sd">            start: Start instruments after setup. If not specified, will use</span>
<span class="sd">                value in ``AcquisitionParameter.continuous``.</span>
<span class="sd">            **kwargs: Additional kwargs passed to `Layout.setup`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">up_to_date</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">layout</span><span class="o">.</span><span class="n">pulse_sequence</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span>

        <span class="n">samples</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;samples&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">layout</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="n">samples</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">continuous</span>

        <span class="k">if</span> <span class="n">start</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">layout</span><span class="o">.</span><span class="n">start</span><span class="p">()</span></div>

<div class="viewcode-block" id="AcquisitionParameter.acquire"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.AcquisitionParameter.acquire">[docs]</a>    <span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">stop</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">setup</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">save_traces</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Performs a `Layout.acquisition`.</span>

<span class="sd">        Args:</span>
<span class="sd">            stop: Stop instruments after acquisition. If not specified, it will</span>
<span class="sd">                stop if ``AcquisitionParameter.continuous`` is False.</span>
<span class="sd">            setup: Whether to setup layout before acquisition.</span>
<span class="sd">                If not specified, it will setup if pulse_sequences are different</span>
<span class="sd">            save_traces: whether to save traces during</span>
<span class="sd">            **kwargs: Additional kwargs to be given to `Layout.acquisition`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            acquisition traces dictionary, segmented by pulse.</span>
<span class="sd">            dictionary has the following format:</span>
<span class="sd">            {pulse.full_name: {acquisition_channel_label: traces}}</span>
<span class="sd">            where acquisition_channel_label is specified in `Layout`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">continuous</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">up_to_date</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">setup</span> <span class="ow">or</span> <span class="p">(</span><span class="n">setup</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">layout</span><span class="o">.</span><span class="n">pulse_sequence</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="p">)</span> <span class="ow">or</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">layout</span><span class="o">.</span><span class="n">samples</span><span class="p">()</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setup</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">save_traces</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">save_traces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_traces</span>
        <span class="k">if</span> <span class="n">save_traces</span> <span class="ow">and</span> <span class="n">active_measurement</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Cannot save traces since there is no active loop&#39;</span><span class="p">)</span>
            <span class="n">save_traces</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Perform acquisition</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">layout</span><span class="o">.</span><span class="n">acquisition</span><span class="p">(</span><span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">,</span>
                                              <span class="n">save_traces</span><span class="o">=</span><span class="n">save_traces</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span></div>

<div class="viewcode-block" id="AcquisitionParameter.analyse"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.AcquisitionParameter.analyse">[docs]</a>    <span class="k">def</span> <span class="nf">analyse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">traces</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Analyse traces, should be implemented in subclass&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;`analyse` must be implemented in subclass&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="AcquisitionParameter.plot_traces"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.AcquisitionParameter.plot_traces">[docs]</a>    <span class="k">def</span> <span class="nf">plot_traces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">channels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">],</span>
                    <span class="n">t_skip</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="n">plot_traces</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">pulse_name</span><span class="p">,</span> <span class="n">trace</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">filter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">filter</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="nb">filter</span> <span class="o">=</span> <span class="p">[</span><span class="nb">filter</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">elem</span> <span class="ow">in</span> <span class="n">pulse_name</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">):</span>
                    <span class="k">continue</span>

            <span class="n">plot_traces</span><span class="p">[</span><span class="n">pulse_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">trace</span>

        <span class="k">if</span> <span class="n">t_skip</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">start_idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">t_skip</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">start_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_skip</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">*</span> <span class="n">t_skip</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">channels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">subplots</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">plot_traces</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">channels</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">subplots</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">plot_traces</span><span class="p">)</span>
        <span class="n">plot</span> <span class="o">=</span> <span class="n">MatPlot</span><span class="p">(</span><span class="n">subplots</span><span class="o">=</span><span class="n">subplots</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">pulse_name</span><span class="p">,</span> <span class="n">traces</span> <span class="ow">in</span> <span class="n">plot_traces</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
                <span class="n">trace_arr</span> <span class="o">=</span> <span class="n">traces</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span>
                <span class="n">pts</span> <span class="o">=</span> <span class="n">trace_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">t_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pts</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">,</span> <span class="n">pts</span><span class="p">,</span>
                                     <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">trace_arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">plot</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">traces</span><span class="p">[</span><span class="n">channel</span><span class="p">][:,</span><span class="n">start_idx</span><span class="p">:],</span> <span class="n">x</span><span class="o">=</span><span class="n">t_list</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:],</span>
                                <span class="n">y</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">trace_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">plot</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">traces</span><span class="p">[</span><span class="n">channel</span><span class="p">][</span><span class="n">start_idx</span><span class="p">:],</span> <span class="n">x</span><span class="o">=</span><span class="n">t_list</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:])</span>
                <span class="n">plot</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time (s)&#39;</span><span class="p">)</span>
                <span class="n">plot</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">pulse_name</span><span class="p">)</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">plot</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">plot</span></div>

<div class="viewcode-block" id="AcquisitionParameter.print_results"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.AcquisitionParameter.print_results">[docs]</a>    <span class="k">def</span> <span class="nf">print_results</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print results whose keys are in ``AcquisitionParameter.names``&quot;&quot;&quot;</span>
        <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{name}</span><span class="s1">: </span><span class="si">{value:.3f}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{name}</span><span class="s1">: </span><span class="si">{value}</span><span class="s1">&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="AcquisitionParameter.get_raw"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.AcquisitionParameter.get_raw">[docs]</a>    <span class="nd">@clear_single_settings</span>
    <span class="k">def</span> <span class="nf">get_raw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analyse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">silent</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">print_results</span><span class="p">()</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span></div>

<div class="viewcode-block" id="AcquisitionParameter.set"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.AcquisitionParameter.set">[docs]</a>    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform an acquisition with temporarily modified settings</span>

<span class="sd">        Shorthand for:</span>
<span class="sd">        ```</span>
<span class="sd">        AcquisitionParameter.single_settings(**kwargs)</span>
<span class="sd">        AcquisitionParameter()</span>
<span class="sd">        ```</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_settings</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)()</span></div></div>


<span class="k">class</span> <span class="nc">PulseSequenceAcquisitionParameter</span><span class="p">(</span><span class="n">AcquisitionParameter</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">tile_pulses</span><span class="o">=</span><span class="p">[],</span> <span class="n">samples</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tile_pulses</span> <span class="o">=</span> <span class="n">tile_pulses</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[],</span> <span class="n">shapes</span><span class="o">=</span><span class="p">[],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tile_pulses</span> <span class="o">=</span> <span class="n">tile_pulses</span>

    <span class="nd">@property_ignore_setter</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">acquire_pulses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">get_pulses</span><span class="p">(</span><span class="n">acquire</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">acquire_pulse_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">pulse</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">pulse</span> <span class="ow">in</span> <span class="n">acquire_pulses</span>
                               <span class="k">if</span> <span class="ow">not</span> <span class="n">pulse</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_pulses</span><span class="p">]</span>
        <span class="n">acquire_pulse_names</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_pulses</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">acquire_pulse_names</span>

    <span class="nd">@property_ignore_setter</span>
    <span class="k">def</span> <span class="nf">labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span>

    <span class="nd">@property_ignore_setter</span>
    <span class="k">def</span> <span class="nf">shapes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">trace_shapes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">get_trace_shapes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">,</span>
                                                            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>

        <span class="c1"># Tile pulses</span>
        <span class="k">for</span> <span class="n">acquire_pulse_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">acquire_pulse_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_pulses</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">pulse_trace_shapes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">pulse_name</span><span class="p">,</span> <span class="n">pulse_shape</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">trace_shapes</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">pulse_name</span> <span class="o">==</span> <span class="n">acquire_pulse_name</span>
                    <span class="ow">or</span> <span class="n">pulse_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{acquire_pulse_name}</span><span class="s1">[&#39;</span><span class="p">)):</span>
                    <span class="n">pulse_trace_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pulse_shape</span><span class="p">)</span>
                    <span class="n">trace_shapes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">pulse_name</span><span class="p">)</span>

            <span class="n">pulse_trace_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pulse_trace_shapes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">pulse_trace_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">pulse_trace_shapes</span><span class="p">)</span>

            <span class="n">trace_shapes</span><span class="p">[</span><span class="n">acquire_pulse_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">pulse_trace_shape</span>

        <span class="k">return</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">trace_shapes</span><span class="p">[</span><span class="n">name</span><span class="p">])</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">analyse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">traces</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">traces</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">traces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span>

        <span class="n">tile_indices</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">}</span>

        <span class="n">tiled_traces</span> <span class="o">=</span> <span class="p">{</span><span class="n">acquire_pulse_name</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">acquire_pulse_name</span><span class="p">,</span> <span class="n">shape</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">,</span>
                                                             <span class="bp">self</span><span class="o">.</span><span class="n">shapes</span><span class="p">)}</span>
        <span class="k">for</span> <span class="n">acquire_pulse_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">acquire_pulse_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_pulses</span><span class="p">:</span>
                <span class="n">tiled_traces</span><span class="p">[</span><span class="n">acquire_pulse_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">traces</span><span class="p">[</span><span class="n">acquire_pulse_name</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tile_traces</span> <span class="o">=</span> <span class="p">{</span><span class="n">pulse_name</span><span class="p">:</span> <span class="n">trace</span> <span class="k">for</span> <span class="n">pulse_name</span><span class="p">,</span> <span class="n">trace</span> <span class="ow">in</span> <span class="n">traces</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                               <span class="k">if</span> <span class="p">(</span><span class="n">pulse_name</span> <span class="o">==</span> <span class="n">acquire_pulse_name</span>
                                   <span class="ow">or</span> <span class="n">pulse_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{acquire_pulse_name}</span><span class="s1">[&#39;</span><span class="p">))}</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tile_traces</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">tiled_traces</span><span class="p">[</span><span class="n">acquire_pulse_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">tiled_traces</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pulse_ids</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">pulse_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;[&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;]&#39;</span><span class="p">))</span>
                                       <span class="k">for</span> <span class="n">pulse_name</span> <span class="ow">in</span> <span class="n">traces</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">pulse_id</span> <span class="ow">in</span> <span class="n">pulse_ids</span><span class="p">:</span>
                        <span class="n">trace</span> <span class="o">=</span> <span class="n">traces</span><span class="p">[</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{acquire_pulse_name}</span><span class="s1">[</span><span class="si">{pulse_id}</span><span class="s1">]&#39;</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">]</span>

                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                            <span class="n">idx_increment</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">idx_increment</span> <span class="o">=</span> <span class="mi">1</span>

                        <span class="n">tile_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">tile_indices</span><span class="p">[</span><span class="n">acquire_pulse_name</span><span class="p">],</span>
                                           <span class="n">tile_indices</span><span class="p">[</span><span class="n">acquire_pulse_name</span><span class="p">]</span><span class="o">+</span><span class="n">idx_increment</span><span class="p">)</span>
                        <span class="n">tiled_traces</span><span class="p">[</span><span class="n">acquire_pulse_name</span><span class="p">][</span><span class="o">...</span><span class="p">,</span> <span class="n">tile_slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">trace</span>
                        <span class="n">tile_indices</span><span class="p">[</span><span class="n">acquire_pulse_name</span><span class="p">]</span> <span class="o">+=</span> <span class="n">idx_increment</span>

        <span class="k">return</span> <span class="n">tiled_traces</span>


<div class="viewcode-block" id="DCParameter"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.DCParameter">[docs]</a><span class="k">class</span> <span class="nc">DCParameter</span><span class="p">(</span><span class="n">AcquisitionParameter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Acquires DC voltage</span>

<span class="sd">    The pulse sequence contains a single read pulse, the duration of which</span>
<span class="sd">    specifies how long should be averaged.</span>

<span class="sd">    Args:</span>
<span class="sd">        name: Parameter name.</span>
<span class="sd">        unit: Unit of DC voltage (e.g. can be changed to nA)</span>

<span class="sd">    Parameters:</span>
<span class="sd">        pulse_sequence (PulseSequence): Pulse sequence used for acquisition.</span>
<span class="sd">        samples (int): Number of acquisition samples</span>
<span class="sd">        results (dict): Results obtained after analysis of traces.</span>
<span class="sd">        traces (dict): Acquisition traces segmented by pulse and acquisition</span>
<span class="sd">            label</span>
<span class="sd">        silent (bool): Print results after acquisition</span>
<span class="sd">        continuous (bool): If True, instruments keep running after acquisition.</span>
<span class="sd">            Useful if stopping/starting instruments takes a considerable amount</span>
<span class="sd">            of time.</span>
<span class="sd">        properties_attrs (List[str]): Attributes to match with</span>
<span class="sd">            ``silq.config.properties`` See notes below for more info.</span>
<span class="sd">        save_traces (bool): Save acquired traces to disk.</span>
<span class="sd">            If the acquisition has been part of a measurement, the traces are</span>
<span class="sd">            stored in a subfolder of the corresponding data set.</span>
<span class="sd">            Otherwise, a new dataset is created.</span>
<span class="sd">        dataset (DataSet): Traces DataSet</span>
<span class="sd">        base_folder (str): Base folder in which to save traces. If not specified,</span>
<span class="sd">            and acquisition is part of a measurement, the base folder is the</span>
<span class="sd">            folder of the measurement data set. Otherwise, the base folder is</span>
<span class="sd">            the default data folder</span>
<span class="sd">        subfolder (str): Subfolder within the base folder to save traces.</span>

<span class="sd">    Returns:</span>
<span class="sd">        DC_voltage: Average DC voltage measured on the output channel</span>
<span class="sd">        DC_noise: noise standard deviation measured on the output channel</span>

<span class="sd">    Notes:</span>
<span class="sd">        - ``DCParameter.continuous`` is True by default</span>

<span class="sd">    Todo:</span>
<span class="sd">        implement continuous acquisition in the ATS interface</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;DC&#39;</span><span class="p">,</span>
                 <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span> <span class="o">=</span> <span class="n">PulseSequence</span><span class="p">([</span>
            <span class="n">DCPulse</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;DC&#39;</span><span class="p">,</span> <span class="n">acquire</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="n">DCPulse</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;DC_final&#39;</span><span class="p">)])</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                         <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;DC_voltage&#39;</span><span class="p">,</span> <span class="s1">&#39;DC_noise&#39;</span><span class="p">],</span>
                         <span class="n">units</span><span class="o">=</span><span class="p">[</span><span class="n">unit</span><span class="p">,</span> <span class="n">unit</span><span class="p">],</span>
                         <span class="n">snapshot_value</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">continuous</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="mi">1</span>

<div class="viewcode-block" id="DCParameter.analyse"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.DCParameter.analyse">[docs]</a>    <span class="k">def</span> <span class="nf">analyse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">traces</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">traces</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">traces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;DC_voltage&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">traces</span><span class="p">[</span><span class="s1">&#39;DC&#39;</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">]),</span>
                <span class="s1">&#39;DC_noise&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">traces</span><span class="p">[</span><span class="s1">&#39;DC&#39;</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">])}</span></div></div>


<div class="viewcode-block" id="TraceParameter"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.TraceParameter">[docs]</a><span class="k">class</span> <span class="nc">TraceParameter</span><span class="p">(</span><span class="n">AcquisitionParameter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An acquisition parameter for obtaining a trace or multiple traces</span>
<span class="sd">    of a given PulseSequence.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; parameter.average_mode = &#39;none&#39;</span>
<span class="sd">        &gt;&gt;&gt; parameter.pulse_sequence = my_pulse_sequence</span>

<span class="sd">        Note that for the above example, all pulses in my_pulse_sequence will be</span>
<span class="sd">        copied.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        trace_pulse (Pulse): Acquisition measurement pulse.</span>
<span class="sd">            Duration is dynamically set to the duration of acquired pulses.</span>
<span class="sd">        pulse_sequence (PulseSequence): Pulse sequence used for acquisition.</span>
<span class="sd">        samples (int): Number of acquisition samples</span>
<span class="sd">        results (dict): Results obtained after analysis of traces.</span>
<span class="sd">        traces (dict): Acquisition traces segmented by pulse and acquisition</span>
<span class="sd">            label</span>
<span class="sd">        silent (bool): Print results after acquisition</span>
<span class="sd">        continuous (bool): If True, instruments keep running after acquisition.</span>
<span class="sd">            Useful if stopping/starting instruments takes a considerable amount</span>
<span class="sd">            of time.</span>
<span class="sd">        properties_attrs (List[str]): Attributes to match with</span>
<span class="sd">            ``silq.config.properties`` See notes below for more info.</span>
<span class="sd">        save_traces (bool): Save acquired traces to disk.</span>
<span class="sd">            If the acquisition has been part of a measurement, the traces are</span>
<span class="sd">            stored in a subfolder of the corresponding data set.</span>
<span class="sd">            Otherwise, a new dataset is created.</span>
<span class="sd">        dataset (DataSet): Traces DataSet</span>
<span class="sd">        base_folder (str): Base folder in which to save traces. If not specified,</span>
<span class="sd">            and acquisition is part of a measurement, the base folder is the</span>
<span class="sd">            folder of the measurement data set. Otherwise, the base folder is</span>
<span class="sd">            the default data folder</span>
<span class="sd">        subfolder (str): Subfolder within the base folder to save traces.</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;trace_pulse&#39;</span><span class="p">,</span> <span class="n">average_mode</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_average_mode</span> <span class="o">=</span> <span class="n">average_mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pulse_sequence</span> <span class="o">=</span> <span class="n">PulseSequence</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trace_pulse</span> <span class="o">=</span> <span class="n">MeasurementPulse</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span>
                                            <span class="n">average</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">average_mode</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pulse_sequence</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trace_pulse</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Trace_acquisition&#39;</span><span class="p">,</span>
                         <span class="n">names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">,</span>
                         <span class="n">units</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">,</span>
                         <span class="n">shapes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shapes</span><span class="p">,</span>
                         <span class="n">snapshot_value</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">average_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Acquisition averaging mode.</span>

<span class="sd">        The attribute `Pulse.average` is overridden.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_average_mode</span>

    <span class="nd">@average_mode</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">average_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_average_mode</span> <span class="o">!=</span> <span class="n">mode</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_average_mode</span> <span class="o">=</span> <span class="n">mode</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace_pulse</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">trace_pulse</span><span class="o">.</span><span class="n">average</span> <span class="o">=</span> <span class="n">mode</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pulse_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pulse_sequence</span>

    <span class="nd">@pulse_sequence</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">pulse_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pulse_sequence</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pulse_sequence</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">pulse_sequence</span><span class="p">)</span>

    <span class="nd">@property_ignore_setter</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trace_pulse</span><span class="o">.</span><span class="n">full_name</span> <span class="o">+</span> <span class="n">f</span><span class="s1">&#39;_</span><span class="si">{output[1]}</span><span class="s1">&#39;</span>
                     <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">layout</span><span class="o">.</span><span class="n">acquisition_channels</span><span class="p">())</span>

    <span class="nd">@property_ignore_setter</span>
    <span class="k">def</span> <span class="nf">labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{output[1]}</span><span class="s1"> Trace&#39;</span>
                     <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">layout</span><span class="o">.</span><span class="n">acquisition_channels</span><span class="p">())</span>

    <span class="nd">@property_ignore_setter</span>
    <span class="k">def</span> <span class="nf">units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layout</span><span class="o">.</span><span class="n">acquisition_channels</span><span class="p">())</span>

    <span class="nd">@property_ignore_setter</span>
    <span class="k">def</span> <span class="nf">shapes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace_pulse</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="p">:</span>
            <span class="n">trace_shapes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">get_trace_shapes</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">layout</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>
            <span class="n">trace_pulse_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">trace_shapes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">trace_pulse</span><span class="o">.</span><span class="n">full_name</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">average_mode</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">((</span><span class="n">trace_pulse_shape</span><span class="p">,),)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layout</span><span class="o">.</span><span class="n">acquisition_channels</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">((</span><span class="n">trace_pulse_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">),</span> <span class="p">)</span> <span class="o">*</span> \
                        <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layout</span><span class="o">.</span><span class="n">acquisition_channels</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">((</span><span class="mi">1</span><span class="p">,),)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layout</span><span class="o">.</span><span class="n">acquisition_channels</span><span class="p">())</span>


    <span class="nd">@property_ignore_setter</span>
    <span class="k">def</span> <span class="nf">setpoints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace_pulse</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="p">:</span>
            <span class="n">duration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace_pulse</span><span class="o">.</span><span class="n">duration</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">((</span><span class="mi">1</span><span class="p">,),)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layout</span><span class="o">.</span><span class="n">acquisition_channels</span><span class="p">())</span>

        <span class="n">num_traces</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layout</span><span class="o">.</span><span class="n">acquisition_channels</span><span class="p">())</span>

        <span class="n">pts</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">duration</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">))</span>
        <span class="n">t_list</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">pts</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">average_mode</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
            <span class="n">setpoints</span> <span class="o">=</span> <span class="p">((</span><span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)),</span>
                          <span class="n">t_list</span><span class="p">),</span> <span class="p">)</span> <span class="o">*</span> <span class="n">num_traces</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">setpoints</span> <span class="o">=</span> <span class="p">((</span><span class="n">t_list</span><span class="p">,</span> <span class="p">),</span> <span class="p">)</span> <span class="o">*</span> <span class="n">num_traces</span>
        <span class="k">return</span> <span class="n">setpoints</span>

    <span class="nd">@property_ignore_setter</span>
    <span class="k">def</span> <span class="nf">setpoint_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">average_mode</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">((</span><span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="p">),</span> <span class="p">)</span> <span class="o">*</span> \
                   <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layout</span><span class="o">.</span><span class="n">acquisition_channels</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">((</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="p">),</span> <span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layout</span><span class="o">.</span><span class="n">acquisition_channels</span><span class="p">())</span>


    <span class="nd">@property_ignore_setter</span>
    <span class="k">def</span> <span class="nf">setpoint_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">average_mode</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">((</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="p">),</span> <span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layout</span><span class="o">.</span><span class="n">acquisition_channels</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">((</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="p">),</span> <span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layout</span><span class="o">.</span><span class="n">acquisition_channels</span><span class="p">())</span>

<div class="viewcode-block" id="TraceParameter.setup"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.TraceParameter.setup">[docs]</a>    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Modifies provided pulse sequence by creating a single</span>
<span class="sd">        pulse which overlaps all other pulses with acquire=True and</span>
<span class="sd">        then acquires only this pulse.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">acquired_pulses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">get_pulses</span><span class="p">(</span><span class="n">acquire</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">acquired_pulses</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;PulseSequence has no pulses to acquire.&#39;</span><span class="p">)</span>

        <span class="c1"># Find the start and stop times for all acquired pulses</span>
        <span class="n">t_start</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">pulse</span><span class="o">.</span><span class="n">t_start</span> <span class="k">for</span> <span class="n">pulse</span> <span class="ow">in</span> <span class="n">acquired_pulses</span><span class="p">)</span>
        <span class="n">t_stop</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">pulse</span><span class="o">.</span><span class="n">t_stop</span> <span class="k">for</span> <span class="n">pulse</span> <span class="ow">in</span> <span class="n">acquired_pulses</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">trace_pulse</span><span class="o">.</span><span class="n">t_start</span> <span class="o">=</span> <span class="n">t_start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trace_pulse</span><span class="o">.</span><span class="n">t_stop</span> <span class="o">=</span> <span class="n">t_stop</span>

        <span class="c1"># Ensure that each pulse is not acquired as this could cause</span>
        <span class="c1"># overlapping issues</span>
        <span class="k">for</span> <span class="n">pulse</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pulse</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace_pulse</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">pulse</span><span class="o">.</span><span class="n">acquire</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Remove any existing trace pulse</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace_pulse</span><span class="o">.</span><span class="n">full_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trace_pulse</span><span class="o">.</span><span class="n">full_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trace_pulse</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="TraceParameter.acquire"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.TraceParameter.acquire">[docs]</a>    <span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Acquires the number of traces defined in self.samples</span>

<span class="sd">        Args:</span>
<span class="sd">            **kwargs: kwargs passed to `AcquisitionParameter.acquire`</span>

<span class="sd">        Returns:</span>
<span class="sd">            A tuple of data points. e.g.</span>
<span class="sd">            ((data_for_1st_output), (data_for_2nd_output), ...)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">traces</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">trace_pulse</span><span class="o">.</span><span class="n">full_name</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">output</span><span class="p">:</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">trace_pulse</span><span class="o">.</span><span class="n">full_name</span><span class="p">][</span><span class="n">output</span><span class="p">]</span>
                  <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">output</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">layout</span><span class="o">.</span><span class="n">acquisition_channels</span><span class="p">()}</span>

        <span class="k">return</span> <span class="n">traces</span></div>

<div class="viewcode-block" id="TraceParameter.analyse"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.TraceParameter.analyse">[docs]</a>    <span class="k">def</span> <span class="nf">analyse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">traces</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rearrange traces to match ``AcquisitionParameter.names``&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">traces</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">traces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span>

        <span class="k">return</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="p">:</span> <span class="n">traces</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">traces</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="nb">float</span><span class="p">)</span>
                <span class="k">else</span> <span class="n">traces</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">traces</span><span class="p">)}</span></div></div>


<div class="viewcode-block" id="DCSweepParameter"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.DCSweepParameter">[docs]</a><span class="k">class</span> <span class="nc">DCSweepParameter</span><span class="p">(</span><span class="n">AcquisitionParameter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perform 1D and 2D DC sweeps by rapidly varying AWG output voltages</span>

<span class="sd">    Using this parameter, a 2D DC sweep of 100x100 points can be obtained in</span>
<span class="sd">    ~1 second. This does of course depend on the filtering of the lines, and the</span>
<span class="sd">    acquisition sampling rate. This is used in the `DCSweepPlot` to continuously</span>
<span class="sd">    update and display the charge stability diagram.</span>

<span class="sd">    The pulse sequence is created by first calling `DCSweepParameter.add_sweep`,</span>
<span class="sd">    which adds a dimension every time it&#39;s called.</span>
<span class="sd">    After adding the sweeps, `DCSweepParameter.generate` will create the</span>
<span class="sd">    corresponding `PulseSequence`.</span>

<span class="sd">    Args:</span>
<span class="sd">        name: parameter name</span>
<span class="sd">        **kwargs: Additional kwargs passed to AcquisitionParameter</span>

<span class="sd">    Parameters:</span>
<span class="sd">        trace_pulse (Pulse): Trace pulse at fixed voltage at the end of sweep.</span>
<span class="sd">            Can be turned off by ``trace_pulse.enabled = False``.</span>
<span class="sd">        pulse_duration (float): Duration of each point in DC sweep</span>
<span class="sd">        final_delay (float): Delay at end of pulse sequence.</span>
<span class="sd">        inter_delay (float): Delay after each row of DC points</span>
<span class="sd">        use_ramp (bool): Combine single row of DC points into a ramp pulse that</span>
<span class="sd">            will be segmented later. This saves number of waveforms sent,</span>
<span class="sd">            reduces triggers, and creates less `Pulse` objects.</span>
<span class="sd">        sweep_parameters (UpdateDotDict): Sweep parameters. Every time an item</span>
<span class="sd">            is updated, `DCSweepParameter.generate` is called.</span>
<span class="sd">        pulse_sequence (PulseSequence): Pulse sequence used for acquisition.</span>
<span class="sd">        samples (int): Number of acquisition samples</span>
<span class="sd">        results (dict): Results obtained after analysis of traces.</span>
<span class="sd">        traces (dict): Acquisition traces segmented by pulse and acquisition</span>
<span class="sd">            label</span>
<span class="sd">        silent (bool): Print results after acquisition</span>
<span class="sd">        continuous (bool): If True, instruments keep running after acquisition.</span>
<span class="sd">            Useful if stopping/starting instruments takes a considerable amount</span>
<span class="sd">            of time.</span>
<span class="sd">        properties_attrs (List[str]): Attributes to match with</span>
<span class="sd">            ``silq.config.properties`` See notes below for more info.</span>
<span class="sd">        save_traces (bool): Save acquired traces to disk.</span>
<span class="sd">            If the acquisition has been part of a measurement, the traces are</span>
<span class="sd">            stored in a subfolder of the corresponding data set.</span>
<span class="sd">            Otherwise, a new dataset is created.</span>
<span class="sd">        dataset (DataSet): Traces DataSet</span>
<span class="sd">        base_folder (str): Base folder in which to save traces. If not specified,</span>
<span class="sd">            and acquisition is part of a measurement, the base folder is the</span>
<span class="sd">            folder of the measurement data set. Otherwise, the base folder is</span>
<span class="sd">            the default data folder</span>
<span class="sd">        subfolder (str): Subfolder within the base folder to save traces.</span>

<span class="sd">    Note:</span>
<span class="sd">        Currently only works up to 2D.</span>

<span class="sd">    Todo:</span>
<span class="sd">        Convert pulse sequence and generator into `PulseSequenceGenerator`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">connect_to_config</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Whether pulses should connect to config (speedup)</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;DC_sweep&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sweep_parameters</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="c1"># Pulse to acquire trace at the end, disabled by default</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trace_pulse</span> <span class="o">=</span> <span class="n">DCPulse</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;trace&#39;</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mf">100e-3</span><span class="p">,</span> <span class="n">enabled</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                   <span class="n">acquire</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;trace&#39;</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_duration</span> <span class="o">=</span> <span class="mf">1e-3</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final_delay</span> <span class="o">=</span> <span class="mf">120e-3</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inter_delay</span> <span class="o">=</span> <span class="mf">200e-6</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_ramp</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">additional_pulses</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;DC_voltage&#39;</span><span class="p">],</span>
                         <span class="n">units</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;V&#39;</span><span class="p">],</span>
                         <span class="n">snapshot_value</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">setpoint_names</span><span class="o">=</span><span class="p">((</span><span class="s1">&#39;None&#39;</span><span class="p">,),),</span>
                         <span class="n">shapes</span><span class="o">=</span><span class="p">((</span><span class="mi">1</span><span class="p">,),),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sweep_parameters</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>

    <span class="nd">@property_ignore_setter</span>
    <span class="k">def</span> <span class="nf">setpoints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">iter_sweep_parameters</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sweep_parameters</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sweep_parameters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sweep_dict</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">iter_sweep_parameters</span><span class="p">)</span>
            <span class="n">sweep_voltages</span> <span class="o">=</span> <span class="n">sweep_dict</span><span class="o">.</span><span class="n">sweep_voltages</span>
            <span class="k">if</span> <span class="n">sweep_dict</span><span class="o">.</span><span class="n">offset_parameter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sweep_voltages</span> <span class="o">=</span> <span class="n">sweep_voltages</span> <span class="o">+</span> <span class="n">sweep_dict</span><span class="o">.</span><span class="n">offset_parameter</span><span class="p">()</span>
            <span class="n">setpoints</span> <span class="o">=</span> <span class="p">(</span><span class="n">convert_setpoints</span><span class="p">(</span><span class="n">sweep_voltages</span><span class="p">),),</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sweep_parameters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">inner_sweep_dict</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">iter_sweep_parameters</span><span class="p">)</span>
            <span class="n">inner_sweep_voltages</span> <span class="o">=</span> <span class="n">inner_sweep_dict</span><span class="o">.</span><span class="n">sweep_voltages</span>
            <span class="k">if</span> <span class="n">inner_sweep_dict</span><span class="o">.</span><span class="n">offset_parameter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">inner_sweep_voltages</span> <span class="o">=</span> <span class="n">inner_sweep_voltages</span> <span class="o">+</span> <span class="n">inner_sweep_dict</span><span class="o">.</span><span class="n">offset_parameter</span><span class="p">()</span>
            <span class="n">outer_sweep_dict</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">iter_sweep_parameters</span><span class="p">)</span>
            <span class="n">outer_sweep_voltages</span> <span class="o">=</span> <span class="n">outer_sweep_dict</span><span class="o">.</span><span class="n">sweep_voltages</span>
            <span class="k">if</span> <span class="n">outer_sweep_dict</span><span class="o">.</span><span class="n">offset_parameter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">outer_sweep_voltages</span> <span class="o">=</span> <span class="n">outer_sweep_voltages</span> <span class="o">+</span> <span class="n">outer_sweep_dict</span><span class="o">.</span><span class="n">offset_parameter</span><span class="p">()</span>

            <span class="n">setpoints</span> <span class="o">=</span> <span class="p">(</span><span class="n">convert_setpoints</span><span class="p">(</span><span class="n">outer_sweep_voltages</span><span class="p">,</span>
                                           <span class="n">inner_sweep_voltages</span><span class="p">)),</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace_pulse</span><span class="o">.</span><span class="n">enabled</span><span class="p">:</span>
            <span class="c1"># Also obtain a time trace at the end</span>
            <span class="n">points</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trace_pulse</span><span class="o">.</span><span class="n">duration</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">)</span>
            <span class="n">trace_setpoints</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace_pulse</span><span class="o">.</span><span class="n">duration</span><span class="p">,</span> <span class="n">points</span><span class="p">))</span>
            <span class="n">setpoints</span> <span class="o">+=</span> <span class="p">(</span><span class="n">convert_setpoints</span><span class="p">(</span><span class="n">trace_setpoints</span><span class="p">),)</span>
        <span class="k">return</span> <span class="n">setpoints</span>

    <span class="nd">@property_ignore_setter</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace_pulse</span><span class="o">.</span><span class="n">enabled</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;DC_voltage&#39;</span><span class="p">,</span> <span class="s1">&#39;trace_voltage&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;DC_voltage&#39;</span><span class="p">,)</span>

    <span class="nd">@property_ignore_setter</span>
    <span class="k">def</span> <span class="nf">labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace_pulse</span><span class="o">.</span><span class="n">enabled</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;DC voltage&#39;</span><span class="p">,</span> <span class="s1">&#39;Trace voltage&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;DC voltage&#39;</span><span class="p">,)</span>

    <span class="nd">@property_ignore_setter</span>
    <span class="k">def</span> <span class="nf">units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace_pulse</span><span class="o">.</span><span class="n">enabled</span> <span class="k">else</span> <span class="p">(</span><span class="s1">&#39;V&#39;</span><span class="p">,)</span>

    <span class="nd">@property_ignore_setter</span>
    <span class="k">def</span> <span class="nf">shapes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">iter_sweep_parameters</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sweep_parameters</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sweep_parameters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">shapes</span> <span class="o">=</span> <span class="p">(),</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sweep_parameters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sweep_voltages</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">iter_sweep_parameters</span><span class="p">)</span><span class="o">.</span><span class="n">sweep_voltages</span>
            <span class="n">shapes</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sweep_voltages</span><span class="p">),),</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sweep_parameters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">inner_sweep_voltages</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">iter_sweep_parameters</span><span class="p">)</span><span class="o">.</span><span class="n">sweep_voltages</span>
            <span class="n">outer_sweep_voltages</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">iter_sweep_parameters</span><span class="p">)</span><span class="o">.</span><span class="n">sweep_voltages</span>
            <span class="n">shapes</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">outer_sweep_voltages</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">inner_sweep_voltages</span><span class="p">)),</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace_pulse</span><span class="o">.</span><span class="n">enabled</span><span class="p">:</span>
            <span class="n">shapes</span> <span class="o">+=</span> <span class="p">(</span><span class="nb">round</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">trace_pulse</span><span class="o">.</span><span class="n">duration</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">),),</span>
        <span class="k">return</span> <span class="n">shapes</span>

    <span class="nd">@property_ignore_setter</span>
    <span class="k">def</span> <span class="nf">setpoint_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">iter_sweep_parameters</span> <span class="o">=</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sweep_parameters</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">iter_sweep_parameters</span><span class="p">),</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace_pulse</span><span class="o">.</span><span class="n">enabled</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">+=</span> <span class="p">((</span><span class="s1">&#39;time&#39;</span><span class="p">,),</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">names</span>

    <span class="nd">@property_ignore_setter</span>
    <span class="k">def</span> <span class="nf">setpoint_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">setpoint_units</span> <span class="o">=</span> <span class="p">((</span><span class="s1">&#39;V&#39;</span><span class="p">,)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sweep_parameters</span><span class="p">),)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace_pulse</span><span class="o">.</span><span class="n">enabled</span><span class="p">:</span>
            <span class="n">setpoint_units</span> <span class="o">+=</span> <span class="p">((</span><span class="s1">&#39;s&#39;</span><span class="p">,),</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">setpoint_units</span>

<div class="viewcode-block" id="DCSweepParameter.add_sweep"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.DCSweepParameter.add_sweep">[docs]</a>    <span class="k">def</span> <span class="nf">add_sweep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                  <span class="n">parameter_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                  <span class="n">sweep_voltages</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                  <span class="n">connection_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                  <span class="n">offset_parameter</span><span class="p">:</span> <span class="n">Parameter</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add sweep to ``DCSweepParameter.sweep_parameters``</span>

<span class="sd">        Each call will add a sweep as the outer dimension.</span>

<span class="sd">        Args:</span>
<span class="sd">            parameter_name: Name of parameter (for axis labelling).</span>
<span class="sd">            sweep_voltages: List of sweep voltages. If</span>
<span class="sd">                ``DCSweepParameter.use_ramp`` is True, these must be</span>
<span class="sd">                equidistant.</span>
<span class="sd">            connection_label: Connection label to target pulses to.</span>
<span class="sd">                For multiple sweeps, each connection label must be distinct.</span>
<span class="sd">                Connection labels are defined in ``Layout.acquisition_outputs``.</span>
<span class="sd">            offset_parameter: Parameter used for offsetting the sweep voltages.</span>
<span class="sd">                Usually this is the corresponding DC voltage parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">connection_label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">connection_label</span> <span class="o">=</span> <span class="n">parameter_name</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sweep_parameters</span><span class="p">[</span><span class="n">parameter_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">UpdateDotDict</span><span class="p">(</span>
            <span class="n">update_function</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">generate</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">parameter_name</span><span class="p">,</span>
            <span class="n">sweep_voltages</span><span class="o">=</span><span class="n">sweep_voltages</span><span class="p">,</span> <span class="n">connection_label</span><span class="o">=</span><span class="n">connection_label</span><span class="p">,</span>
            <span class="n">offset_parameter</span><span class="o">=</span><span class="n">offset_parameter</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span></div>

<div class="viewcode-block" id="DCSweepParameter.generate"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.DCSweepParameter.generate">[docs]</a>    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generates pulse sequence using sweeps in `DCSweepParameter.add_sweep`</span>

<span class="sd">        Note:</span>
<span class="sd">            Currently only works for 1D and 2D</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="n">iter_sweep_parameters</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sweep_parameters</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sweep_parameters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sweep_name</span><span class="p">,</span> <span class="n">sweep_dict</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">iter_sweep_parameters</span><span class="p">)</span>
            <span class="n">sweep_voltages</span> <span class="o">=</span> <span class="n">sweep_dict</span><span class="o">.</span><span class="n">sweep_voltages</span>
            <span class="n">connection_label</span> <span class="o">=</span> <span class="n">sweep_dict</span><span class="o">.</span><span class="n">connection_label</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_ramp</span><span class="p">:</span>
                <span class="n">sweep_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sweep_voltages</span><span class="p">)</span>
                <span class="n">pulses</span> <span class="o">=</span> <span class="p">[</span><span class="n">DCRampPulse</span><span class="p">(</span><span class="s1">&#39;DC_inner&#39;</span><span class="p">,</span>
                                      <span class="n">duration</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_duration</span><span class="o">*</span><span class="n">sweep_points</span><span class="p">,</span>
                                      <span class="n">amplitude_start</span><span class="o">=</span><span class="n">sweep_voltages</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                      <span class="n">amplitude_stop</span><span class="o">=</span><span class="n">sweep_voltages</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                      <span class="n">acquire</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                      <span class="n">average</span><span class="o">=</span><span class="n">f</span><span class="s1">&#39;point_segment:</span><span class="si">{sweep_points}</span><span class="s1">&#39;</span><span class="p">,</span>
                                      <span class="n">connection_label</span><span class="o">=</span><span class="n">connection_label</span><span class="p">,</span>
                                      <span class="n">connect_to_config</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">connect_to_config</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pulses</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">DCPulse</span><span class="p">(</span><span class="s1">&#39;DC_inner&#39;</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_duration</span><span class="p">,</span>
                            <span class="n">acquire</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;point&#39;</span><span class="p">,</span>
                            <span class="n">amplitude</span><span class="o">=</span><span class="n">sweep_voltage</span><span class="p">,</span>
                            <span class="n">connection_label</span><span class="o">=</span><span class="n">connection_label</span><span class="p">,</span>
                            <span class="n">connect_to_config</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">connect_to_config</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">sweep_voltage</span> <span class="ow">in</span> <span class="n">sweep_voltages</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span> <span class="o">=</span> <span class="n">PulseSequence</span><span class="p">(</span><span class="n">pulses</span><span class="o">=</span><span class="n">pulses</span><span class="p">)</span>
            <span class="c1">#             self.pulse_sequence.add(*self.additional_pulses)</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sweep_parameters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">inner_sweep_name</span><span class="p">,</span> <span class="n">inner_sweep_dict</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">iter_sweep_parameters</span><span class="p">)</span>
            <span class="n">inner_sweep_voltages</span> <span class="o">=</span> <span class="n">inner_sweep_dict</span><span class="o">.</span><span class="n">sweep_voltages</span>
            <span class="n">inner_connection_label</span> <span class="o">=</span> <span class="n">inner_sweep_dict</span><span class="o">.</span><span class="n">connection_label</span>
            <span class="n">outer_sweep_name</span><span class="p">,</span> <span class="n">outer_sweep_dict</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">iter_sweep_parameters</span><span class="p">)</span>
            <span class="n">outer_sweep_voltages</span> <span class="o">=</span> <span class="n">outer_sweep_dict</span><span class="o">.</span><span class="n">sweep_voltages</span>
            <span class="n">outer_connection_label</span> <span class="o">=</span> <span class="n">outer_sweep_dict</span><span class="o">.</span><span class="n">connection_label</span>

            <span class="n">pulses</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">outer_connection_label</span> <span class="o">==</span> <span class="n">inner_connection_label</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_ramp</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Ramp Pulse not implemented for &#39;</span>
                                              <span class="s1">&#39;CombinedConnection&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">outer_sweep_voltage</span> <span class="ow">in</span> <span class="n">outer_sweep_voltages</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">inner_sweep_voltage</span> <span class="ow">in</span> <span class="n">inner_sweep_voltages</span><span class="p">:</span>
                        <span class="n">sweep_voltage</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">inner_sweep_voltage</span><span class="p">,</span> <span class="n">outer_sweep_voltage</span><span class="p">)</span>
                        <span class="n">pulses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">DCPulse</span><span class="p">(</span><span class="s1">&#39;DC_read&#39;</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_duration</span><span class="p">,</span>
                                    <span class="n">acquire</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="n">sweep_voltage</span><span class="p">,</span>
                                    <span class="n">average</span><span class="o">=</span><span class="s1">&#39;point&#39;</span><span class="p">,</span>
                                    <span class="n">connection_label</span><span class="o">=</span><span class="n">outer_connection_label</span><span class="p">,</span>
                                    <span class="n">connect_to_config</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">connect_to_config</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">sweep_duration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_duration</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">inner_sweep_voltages</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">outer_sweep_voltage</span> <span class="ow">in</span> <span class="n">outer_sweep_voltages</span><span class="p">:</span>
                    <span class="n">pulses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">DCPulse</span><span class="p">(</span><span class="s1">&#39;DC_outer&#39;</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="n">t</span><span class="p">,</span>
                                <span class="n">duration</span><span class="o">=</span><span class="n">sweep_duration</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">inter_delay</span><span class="p">,</span>
                                <span class="n">amplitude</span><span class="o">=</span><span class="n">outer_sweep_voltage</span><span class="p">,</span>
                                <span class="n">connection_label</span><span class="o">=</span><span class="n">outer_connection_label</span><span class="p">,</span>
                                <span class="n">connect_to_config</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">connect_to_config</span><span class="p">))</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inter_delay</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">pulses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">DCPulse</span><span class="p">(</span><span class="s1">&#39;DC_inter_delay&#39;</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="n">t</span><span class="p">,</span>
                                    <span class="n">duration</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">inter_delay</span><span class="p">,</span>
                                    <span class="n">amplitude</span><span class="o">=</span><span class="n">inner_sweep_voltages</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                    <span class="n">connection_label</span><span class="o">=</span><span class="n">inner_connection_label</span><span class="p">,</span>
                                    <span class="n">connect_to_config</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">connect_to_config</span><span class="p">))</span>
                        <span class="n">t</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inter_delay</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_ramp</span><span class="p">:</span>
                        <span class="n">sweep_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">inner_sweep_voltages</span><span class="p">)</span>
                        <span class="n">pulses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">DCRampPulse</span><span class="p">(</span><span class="s1">&#39;DC_inner&#39;</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="n">t</span><span class="p">,</span>
                                        <span class="n">duration</span><span class="o">=</span><span class="n">sweep_duration</span><span class="p">,</span>
                                        <span class="n">amplitude_start</span><span class="o">=</span><span class="n">inner_sweep_voltages</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                        <span class="n">amplitude_stop</span><span class="o">=</span><span class="n">inner_sweep_voltages</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                        <span class="n">acquire</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                        <span class="n">average</span><span class="o">=</span><span class="n">f</span><span class="s1">&#39;point_segment:</span><span class="si">{sweep_points}</span><span class="s1">&#39;</span><span class="p">,</span>
                                        <span class="n">connection_label</span><span class="o">=</span><span class="n">inner_connection_label</span><span class="p">,</span>
                                        <span class="n">connect_to_config</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">connect_to_config</span><span class="p">)</span>
                        <span class="p">)</span>
                        <span class="n">t</span> <span class="o">+=</span> <span class="n">sweep_duration</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">inner_sweep_voltage</span> <span class="ow">in</span> <span class="n">inner_sweep_voltages</span><span class="p">:</span>
                            <span class="n">pulses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="n">DCPulse</span><span class="p">(</span><span class="s1">&#39;DC_inner&#39;</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="n">t</span><span class="p">,</span>
                                        <span class="n">duration</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_duration</span><span class="p">,</span>
                                        <span class="n">acquire</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;point&#39;</span><span class="p">,</span>
                                        <span class="n">amplitude</span><span class="o">=</span><span class="n">inner_sweep_voltage</span><span class="p">,</span>
                                        <span class="n">connection_label</span><span class="o">=</span><span class="n">inner_connection_label</span><span class="p">,</span>
                                        <span class="n">connect_to_config</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">connect_to_config</span><span class="p">)</span>
                            <span class="p">)</span>
                            <span class="n">t</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_duration</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="n">f</span><span class="s2">&quot;Cannot handle {len(self.sweep_parameters)} parameters&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace_pulse</span><span class="o">.</span><span class="n">enabled</span><span class="p">:</span>
            <span class="c1"># Also obtain a time trace at the end</span>
            <span class="n">pulses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trace_pulse</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span> <span class="o">=</span> <span class="n">PulseSequence</span><span class="p">(</span><span class="n">pulses</span><span class="o">=</span><span class="n">pulses</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">final_delay</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_delay</span></div>

<div class="viewcode-block" id="DCSweepParameter.analyse"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.DCSweepParameter.analyse">[docs]</a>    <span class="k">def</span> <span class="nf">analyse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">traces</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Analyse traces, ensuring resulting dimensionality is correct</span>

<span class="sd">        Args:</span>
<span class="sd">            traces: Traces returned by `AcquisitionParameter.acquire`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Dict[str, Any]): Dict containing:</span>

<span class="sd">            :DC_voltage (np.ndarray): DC voltages with dimensionality</span>
<span class="sd">              corresponding to number of sweeps.</span>
<span class="sd">            :trace_voltage (np.ndarray): voltage trace of final trace pulse.</span>
<span class="sd">              Only used if ``DCSweepParameter.trace_pulse.enabled``.</span>
<span class="sd">              Trace in ``output`` connection label is returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">traces</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">traces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span>

        <span class="n">DC_voltages</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">traces</span><span class="p">[</span><span class="n">pulse</span><span class="o">.</span><span class="n">full_name</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">pulse</span> <span class="ow">in</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">get_pulses</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;DC_inner&#39;</span><span class="p">)])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_ramp</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sweep_parameters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">results</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;DC_voltage&#39;</span><span class="p">:</span> <span class="n">DC_voltages</span><span class="p">[</span><span class="mi">0</span><span class="p">]}</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sweep_parameters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">results</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;DC_voltage&#39;</span><span class="p">:</span> <span class="n">DC_voltages</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sweep_parameters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">results</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;DC_voltage&#39;</span><span class="p">:</span> <span class="n">DC_voltages</span><span class="p">}</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sweep_parameters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">results</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;DC_voltage&#39;</span><span class="p">:</span>
                    <span class="n">DC_voltages</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shapes</span><span class="p">[</span><span class="mi">0</span><span class="p">])}</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace_pulse</span><span class="o">.</span><span class="n">enabled</span><span class="p">:</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;trace_voltage&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">traces</span><span class="p">[</span><span class="s1">&#39;trace&#39;</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">results</span></div></div>


<div class="viewcode-block" id="VariableReadParameter"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.VariableReadParameter">[docs]</a><span class="k">class</span> <span class="nc">VariableReadParameter</span><span class="p">(</span><span class="n">AcquisitionParameter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parameter for measuring spin tails.</span>

<span class="sd">    The pulse sequence is ``plunge`` - ``read`` - ``empty``.</span>
<span class="sd">    By varying the read amplitude, the voltage should transition between</span>
<span class="sd">    high voltage (``empty``) to low voltage (``plunge``), and somewhere in</span>
<span class="sd">    between an increased voltage should be visible at the start, indicating</span>
<span class="sd">    spin-dependent tunneling.</span>

<span class="sd">    Args:</span>
<span class="sd">        name: Parameter name</span>
<span class="sd">        **kwargs: Additional kwargs passed to AcquisitionParameter</span>

<span class="sd">    Parameters:</span>
<span class="sd">        pulse_sequence (PulseSequence): Pulse sequence used for acquisition.</span>
<span class="sd">        samples (int): Number of acquisition samples to average over.</span>
<span class="sd">        results (dict): Results obtained after analysis of traces.</span>
<span class="sd">        traces (dict): Acquisition traces segmented by pulse and acquisition</span>
<span class="sd">            label</span>
<span class="sd">        continuous (bool): If True, instruments keep running after acquisition.</span>
<span class="sd">            Useful if stopping/starting instruments takes a considerable amount</span>
<span class="sd">            of time.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;variable_read&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span> <span class="o">=</span> <span class="n">PulseSequence</span><span class="p">([</span>
            <span class="n">DCPulse</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;plunge&#39;</span><span class="p">,</span> <span class="n">acquire</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;trace&#39;</span><span class="p">),</span>
            <span class="n">DCPulse</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;read&#39;</span><span class="p">,</span> <span class="n">acquire</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;trace&#39;</span><span class="p">),</span>
            <span class="n">DCPulse</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;empty&#39;</span><span class="p">,</span> <span class="n">acquire</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;trace&#39;</span><span class="p">)])</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                         <span class="n">names</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;read_voltage&#39;</span><span class="p">,),</span>
                         <span class="n">units</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;V&#39;</span><span class="p">,),</span>
                         <span class="n">shapes</span><span class="o">=</span><span class="p">((</span><span class="mi">1</span><span class="p">,),),</span>
                         <span class="n">setpoint_names</span><span class="o">=</span><span class="p">((</span><span class="s1">&#39;time&#39;</span><span class="p">,),),</span>
                         <span class="n">setpoint_labels</span><span class="o">=</span><span class="p">((</span><span class="s1">&#39;Time&#39;</span><span class="p">,),),</span>
                         <span class="n">setpoint_units</span><span class="o">=</span><span class="p">((</span><span class="s1">&#39;s&#39;</span><span class="p">,),),</span>
                         <span class="n">snapshot_value</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


    <span class="nd">@property_ignore_setter</span>
    <span class="k">def</span> <span class="nf">setpoints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">duration</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">pulse</span><span class="o">.</span><span class="n">duration</span> <span class="k">for</span> <span class="n">pulse</span> <span class="ow">in</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">get_pulses</span><span class="p">(</span><span class="n">acquire</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shapes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])),</span> <span class="p">),</span>

    <span class="nd">@property_ignore_setter</span>
    <span class="k">def</span> <span class="nf">shapes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">shapes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">layout</span><span class="o">.</span><span class="n">acquisition_shapes</span>
        <span class="n">pts</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">shapes</span><span class="p">[</span><span class="n">pulse</span><span class="o">.</span><span class="n">full_name</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                  <span class="k">for</span> <span class="n">pulse</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">get_pulses</span><span class="p">(</span><span class="n">acquire</span><span class="o">=</span><span class="kc">True</span><span class="p">)])</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">pts</span><span class="p">,),</span>

<div class="viewcode-block" id="VariableReadParameter.analyse"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.VariableReadParameter.analyse">[docs]</a>    <span class="k">def</span> <span class="nf">analyse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">traces</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">traces</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">traces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span>

        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;read_voltage&#39;</span><span class="p">:</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">traces</span><span class="p">[</span><span class="n">pulse</span><span class="o">.</span><span class="n">full_name</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">]</span>
                                    <span class="k">for</span> <span class="n">pulse</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">get_pulses</span><span class="p">(</span><span class="n">acquire</span><span class="o">=</span><span class="kc">True</span><span class="p">)])}</span></div></div>


<div class="viewcode-block" id="EPRParameter"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.EPRParameter">[docs]</a><span class="k">class</span> <span class="nc">EPRParameter</span><span class="p">(</span><span class="n">AcquisitionParameter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parameter for an empty-plunge-read sequence.</span>

<span class="sd">    Args:</span>
<span class="sd">        name: Name of acquisition parameter</span>
<span class="sd">        **kwargs: Additional kwargs passed to `AcquisitionParameter`.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        pulse_sequence (PulseSequence): Pulse sequence used for acquisition.</span>
<span class="sd">        samples (int): Number of acquisition samples</span>
<span class="sd">        results (dict): Results obtained after analysis of traces.</span>
<span class="sd">        t_skip (float): initial part of read trace to ignore for measuring</span>
<span class="sd">            blips. Useful if there is a voltage spike at the start, which could</span>
<span class="sd">            otherwise be measured as a ``blip``. Retrieved from</span>
<span class="sd">            ``silq.config.properties.t_skip``.</span>
<span class="sd">        t_read (float): duration of read trace to include for measuring blips.</span>
<span class="sd">            Useful if latter half of read pulse is used for initialization.</span>
<span class="sd">            Retrieved from ``silq.config.properties.t_read``.</span>
<span class="sd">        min_filter_proportion (float): Minimum number of read traces needed in</span>
<span class="sd">            which the voltage starts low (loaded donor). Otherwise, most results</span>
<span class="sd">            are set to zero. Retrieved from</span>
<span class="sd">            ``silq.config.properties.min_filter_proportion``.</span>
<span class="sd">        traces (dict): Acquisition traces segmented by pulse and acquisition</span>
<span class="sd">            label</span>
<span class="sd">        silent (bool): Print results after acquisition</span>
<span class="sd">        continuous (bool): If True, instruments keep running after acquisition.</span>
<span class="sd">            Useful if stopping/starting instruments takes a considerable amount</span>
<span class="sd">            of time.</span>
<span class="sd">        properties_attrs (List[str]): Attributes to match with</span>
<span class="sd">            ``silq.config.properties`` See notes below for more info.</span>
<span class="sd">        save_traces (bool): Save acquired traces to disk.</span>
<span class="sd">            If the acquisition has been part of a measurement, the traces are</span>
<span class="sd">            stored in a subfolder of the corresponding data set.</span>
<span class="sd">            Otherwise, a new dataset is created.</span>
<span class="sd">        dataset (DataSet): Traces DataSet</span>
<span class="sd">        base_folder (str): Base folder in which to save traces. If not specified,</span>
<span class="sd">            and acquisition is part of a measurement, the base folder is the</span>
<span class="sd">            folder of the measurement data set. Otherwise, the base folder is</span>
<span class="sd">            the default data folder</span>
<span class="sd">        subfolder (str): Subfolder within the base folder to save traces.</span>

<span class="sd">    Note:</span>
<span class="sd">        A ``read_long`` pulse is used instead of ``read`` because this allows</span>
<span class="sd">        comparison of the start and end of the pulse, giving the ``contrast``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;EPR&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span> <span class="o">=</span> <span class="n">PulseSequence</span><span class="p">([</span>
            <span class="n">DCPulse</span><span class="p">(</span><span class="s1">&#39;empty&#39;</span><span class="p">,</span> <span class="n">acquire</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="n">DCPulse</span><span class="p">(</span><span class="s1">&#39;plunge&#39;</span><span class="p">,</span> <span class="n">acquire</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="n">DCPulse</span><span class="p">(</span><span class="s1">&#39;read_long&#39;</span><span class="p">,</span> <span class="n">acquire</span><span class="o">=</span><span class="kc">True</span><span class="p">)])</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                         <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;contrast&#39;</span><span class="p">,</span> <span class="s1">&#39;up_proportion&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;dark_counts&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;voltage_difference_read&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;fidelity_empty&#39;</span><span class="p">,</span> <span class="s1">&#39;fidelity_load&#39;</span><span class="p">,</span> <span class="s1">&#39;voltage_average_read&#39;</span><span class="p">],</span>
                         <span class="n">snapshot_value</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">properties_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;t_skip&#39;</span><span class="p">,</span> <span class="s1">&#39;t_read&#39;</span><span class="p">,</span>
                                           <span class="s1">&#39;min_filter_proportion&#39;</span><span class="p">,</span>
                                           <span class="s1">&#39;filter_traces&#39;</span><span class="p">],</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="EPRParameter.analyse"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.EPRParameter.analyse">[docs]</a>    <span class="k">def</span> <span class="nf">analyse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">traces</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">plot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Analyse traces using `analyse_EPR`&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">traces</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">traces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span>

        <span class="n">threshold_voltage</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;threshold_voltage&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">analysis</span><span class="o">.</span><span class="n">analyse_EPR</span><span class="p">(</span>
            <span class="n">empty_traces</span><span class="o">=</span><span class="n">traces</span><span class="p">[</span><span class="s1">&#39;empty&#39;</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">],</span>
            <span class="n">plunge_traces</span><span class="o">=</span><span class="n">traces</span><span class="p">[</span><span class="s1">&#39;plunge&#39;</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">],</span>
            <span class="n">read_traces</span><span class="o">=</span><span class="n">traces</span><span class="p">[</span><span class="s1">&#39;read_long&#39;</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">],</span>
            <span class="n">sample_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">,</span>
            <span class="n">t_skip</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">t_skip</span><span class="p">,</span>
            <span class="n">t_read</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">t_read</span><span class="p">,</span>
            <span class="n">min_filter_proportion</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_filter_proportion</span><span class="p">,</span>
            <span class="n">threshold_voltage</span><span class="o">=</span><span class="n">threshold_voltage</span><span class="p">,</span>
            <span class="n">filter_traces</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_traces</span><span class="p">,</span>
            <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ESRParameter"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.ESRParameter">[docs]</a><span class="k">class</span> <span class="nc">ESRParameter</span><span class="p">(</span><span class="n">AcquisitionParameter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parameter for most pulse sequences involving electron spin resonance.</span>

<span class="sd">    This parameter can handle many of the simple pulse sequences involving ESR.</span>
<span class="sd">    It uses the `ESRPulseSequence`, which will generate a pulse sequence from</span>
<span class="sd">    settings (see parameters below).</span>

<span class="sd">    In general the pulse sequence is as follows:</span>

<span class="sd">    1. Perform any pre_pulses defined in ``ESRParameter.pre_pulses``.</span>
<span class="sd">    2. Perform stage pulse ``ESRParameter.ESR[&#39;stage_pulse&#39;]``.</span>
<span class="sd">       By default, this is the ``plunge`` pulse.</span>
<span class="sd">    3. Perform ESR pulse within plunge pulse, the delay from start of plunge</span>
<span class="sd">       pulse is defined in ``ESRParameter.ESR[&#39;pulse_delay&#39;]``.</span>
<span class="sd">    4. Perform read pulse ``ESRParameter.ESR[&#39;read_pulse&#39;]``.</span>
<span class="sd">    5. Repeat steps 2 and 3 for each ESR pulse in</span>
<span class="sd">       ``ESRParameter.ESR[&#39;ESR_pulses&#39;]``, which by default contains single</span>
<span class="sd">       pulse ``ESRParameter.ESR[&#39;ESR_pulse&#39;]``.</span>
<span class="sd">    6. Perform empty-plunge-read sequence (EPR), but only if</span>
<span class="sd">       ``ESRParameter.EPR[&#39;enabled&#39;]`` is True.</span>
<span class="sd">       EPR pulses are defined in ``ESRParameter.EPR[&#39;pulses&#39;]``.</span>
<span class="sd">    7. Perform any post_pulses defined in ``ESRParameter.post_pulses``.</span>

<span class="sd">    A shorthand for using the default ESR pulse for multiple frequencies is by</span>
<span class="sd">    setting `ESRParameter.ESR_frequencies`. Settings this will create a copy</span>
<span class="sd">    of ESRParameter.ESR[&#39;ESR_pulse&#39;] with the respective frequency.</span>

<span class="sd">    Examples:</span>
<span class="sd">        The following code measures two ESR frequencies and performs an EPR</span>
<span class="sd">        from which the contrast can be determined for each ESR frequency:</span>

<span class="sd">        &gt;&gt;&gt; ESR_parameter = ESRParameter()</span>
<span class="sd">        &gt;&gt;&gt; ESR_parameter.ESR[&#39;pulse_delay&#39;] = 5e-3</span>
<span class="sd">        &gt;&gt;&gt; ESR_parameter.ESR[&#39;stage_pulse&#39;] = DCPulse[&#39;plunge&#39;]</span>
<span class="sd">        &gt;&gt;&gt; ESR_parameter.ESR[&#39;ESR_pulse&#39;] = FrequencyRampPulse(&#39;ESR_adiabatic&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ESR_parameter.ESR_frequencies = [39e9, 39.1e9]</span>
<span class="sd">        &gt;&gt;&gt; ESR_parameter.EPR[&#39;enabled&#39;] = True</span>
<span class="sd">        &gt;&gt;&gt; ESR_parameter.pulse_sequence.generate()</span>

<span class="sd">        The total pulse sequence is plunge-read-plunge-read-empty-plunge-read</span>
<span class="sd">        with an ESR pulse in the first two plunge pulses, 5 ms after the start</span>
<span class="sd">        of the plunge pulse. The ESR pulses have different frequencies.</span>

<span class="sd">    Args:</span>
<span class="sd">        name: Name of acquisition parameter</span>
<span class="sd">        **kwargs: Additional kwargs passed to `AcquisitionParameter`.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        ESR (dict): `ESRPulseSequence` generator settings for ESR. Settings are:</span>
<span class="sd">            ``stage_pulse``, ``ESR_pulse``, ``ESR_pulses``, ``pulse_delay``,</span>
<span class="sd">            ``read_pulse``.</span>
<span class="sd">        EPR (dict): `ESRPulseSequence` generator settings for EPR.</span>
<span class="sd">            This is optional and can be toggled in ``EPR[&#39;enabled&#39;]``.</span>
<span class="sd">            If disabled, contrast is not calculated.</span>
<span class="sd">            Settings are: ``enabled``, ``pulses``.</span>
<span class="sd">        pre_pulses (List[Pulse]): Pulses to place at the start of the sequence.</span>
<span class="sd">        post_pulses (List[Pulse]): Pulses to place at the end of the sequence.</span>
<span class="sd">        pulse_sequence (PulseSequence): Pulse sequence used for acquisition.</span>
<span class="sd">        samples (int): Number of acquisition samples</span>
<span class="sd">        results (dict): Results obtained after analysis of traces.</span>
<span class="sd">        t_skip (float): initial part of read trace to ignore for measuring</span>
<span class="sd">            blips. Useful if there is a voltage spike at the start, which could</span>
<span class="sd">            otherwise be measured as a ``blip``. Retrieved from</span>
<span class="sd">            ``silq.config.properties.t_skip``.</span>
<span class="sd">        t_read (float): duration of read trace to include for measuring blips.</span>
<span class="sd">            Useful if latter half of read pulse is used for initialization.</span>
<span class="sd">            Retrieved from ``silq.config.properties.t_read``.</span>
<span class="sd">        min_filter_proportion (float): Minimum number of read traces needed in</span>
<span class="sd">            which the voltage starts low (loaded donor). Otherwise, most results</span>
<span class="sd">            are set to zero. Retrieved from</span>
<span class="sd">            ``silq.config.properties.min_filter_proportion``.</span>
<span class="sd">        traces (dict): Acquisition traces segmented by pulse and acquisition</span>
<span class="sd">            label</span>
<span class="sd">        silent (bool): Print results after acquisition</span>
<span class="sd">        continuous (bool): If True, instruments keep running after acquisition.</span>
<span class="sd">            Useful if stopping/starting instruments takes a considerable amount</span>
<span class="sd">            of time.</span>
<span class="sd">        properties_attrs (List[str]): Attributes to match with</span>
<span class="sd">            ``silq.config.properties``.</span>
<span class="sd">            See notes below for more info.</span>
<span class="sd">        save_traces (bool): Save acquired traces to disk.</span>
<span class="sd">            If the acquisition has been part of a measurement, the traces are</span>
<span class="sd">            stored in a subfolder of the corresponding data set.</span>
<span class="sd">            Otherwise, a new dataset is created.</span>
<span class="sd">        dataset (DataSet): Traces DataSet</span>
<span class="sd">        base_folder (str): Base folder in which to save traces. If not specified,</span>
<span class="sd">            and acquisition is part of a measurement, the base folder is the</span>
<span class="sd">            folder of the measurement data set. Otherwise, the base folder is</span>
<span class="sd">            the default data folder</span>
<span class="sd">        subfolder (str): Subfolder within the base folder to save traces.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - All pulse settings are copies of</span>
<span class="sd">          ``ESRParameter.pulse_sequence.pulse_settings``.</span>
<span class="sd">        - For given pulse settings, ``ESRParameter.pulse_sequence.generate``</span>
<span class="sd">          will recreate the pulse sequence from settings.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;ESR&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_names</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span> <span class="o">=</span> <span class="n">ESRPulseSequence</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ESR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">ESR</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">EPR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">EPR</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pre_pulses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">pre_pulses</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">post_pulses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">post_pulses</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                         <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;contrast&#39;</span><span class="p">,</span> <span class="s1">&#39;dark_counts&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;voltage_difference_read&#39;</span><span class="p">],</span>
                         <span class="n">snapshot_value</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">properties_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;t_skip&#39;</span><span class="p">,</span> <span class="s1">&#39;t_read&#39;</span><span class="p">,</span>
                                           <span class="s1">&#39;min_filter_proportion&#39;</span><span class="p">,</span>
                                           <span class="s1">&#39;filter_traces&#39;</span><span class="p">],</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">EPR</span><span class="p">[</span><span class="s1">&#39;enabled&#39;</span><span class="p">]:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Ignore all names, only add the ESR up proportions</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="s1">&#39;voltage_difference&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="p">:</span>
                <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;voltage_difference&#39;</span><span class="p">)</span>

        <span class="n">ESR_pulse_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">pulse</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">pulse</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">primary_ESR_pulses</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">pulse</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">primary_ESR_pulses</span><span class="p">:</span>
            <span class="n">pulse_name</span> <span class="o">=</span> <span class="n">pulse</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pulse</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">pulse</span><span class="o">.</span><span class="n">name</span>

            <span class="k">if</span> <span class="n">ESR_pulse_names</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">pulse_name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Ignore suffix</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">pulse_name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">suffix</span><span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span>
                             <span class="k">if</span> <span class="n">f</span><span class="s1">&#39;up_proportion_</span><span class="si">{pulse_name}</span><span class="s1">&#39;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">])</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{pulse_name}</span><span class="s1">_</span><span class="si">{suffix}</span><span class="s1">&#39;</span>
            <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;up_proportion_</span><span class="si">{name}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">EPR</span><span class="p">[</span><span class="s1">&#39;enabled&#39;</span><span class="p">]:</span>
                <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;contrast_</span><span class="si">{name}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;num_traces_</span><span class="si">{name}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">names</span>

    <span class="nd">@names</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set all the names to return upon .get() for the EPR sequence&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span>
                       <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;contrast_&#39;</span> <span class="ow">in</span> <span class="n">name</span>
                       <span class="ow">and</span> <span class="ow">not</span> <span class="s1">&#39;up_proportion_&#39;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">]</span>

    <span class="nd">@property_ignore_setter</span>
    <span class="k">def</span> <span class="nf">shapes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">((),</span> <span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>

    <span class="nd">@property_ignore_setter</span>
    <span class="k">def</span> <span class="nf">units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ESR_frequencies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply default ESR pulse for each ESR frequency given.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">ESR_frequencies</span>

    <span class="nd">@ESR_frequencies</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">ESR_frequencies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ESR_frequencies</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">ESR_frequencies</span><span class="o">=</span><span class="n">ESR_frequencies</span><span class="p">)</span>

<div class="viewcode-block" id="ESRParameter.analyse"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.ESRParameter.analyse">[docs]</a>    <span class="k">def</span> <span class="nf">analyse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">traces</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Analyse ESR traces.</span>

<span class="sd">        If there is only one ESR pulse, returns ``up_proportion_{pulse.name}``.</span>
<span class="sd">        If there are several ESR pulses, adds a zero-based suffix at the end for</span>
<span class="sd">        each ESR pulse. If ``ESRParameter.EPR[&#39;enabled&#39;] == True``, the results</span>
<span class="sd">        from `analyse_EPR` are also added, as well as ``contrast_{pulse.name}``</span>
<span class="sd">        (plus a suffix if there are several ESR pulses).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">traces</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">traces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span>

        <span class="n">threshold_voltage</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;threshold_voltage&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">EPR</span><span class="p">[</span><span class="s1">&#39;enabled&#39;</span><span class="p">]:</span>
            <span class="c1"># Analyse EPR sequence, which also gets the dark counts</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">analysis</span><span class="o">.</span><span class="n">analyse_EPR</span><span class="p">(</span>
                <span class="n">empty_traces</span><span class="o">=</span><span class="n">traces</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">_EPR_pulses</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">full_name</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">],</span>
                <span class="n">plunge_traces</span><span class="o">=</span><span class="n">traces</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">_EPR_pulses</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">full_name</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">],</span>
                <span class="n">read_traces</span><span class="o">=</span><span class="n">traces</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">_EPR_pulses</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">full_name</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">],</span>
                <span class="n">sample_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">,</span>
                <span class="n">min_filter_proportion</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_filter_proportion</span><span class="p">,</span>
                <span class="n">threshold_voltage</span><span class="o">=</span><span class="n">threshold_voltage</span><span class="p">,</span>
                <span class="n">filter_traces</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_traces</span><span class="p">,</span>
                <span class="n">t_skip</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">t_skip</span><span class="p">,</span> <span class="c1"># Use t_skip to keep length consistent</span>
                <span class="n">t_read</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">t_read</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">ESR_pulses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">primary_ESR_pulses</span>
        <span class="n">ESR_pulse_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">pulse</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">pulse</span> <span class="ow">in</span> <span class="n">ESR_pulses</span><span class="p">]</span>
        <span class="n">read_pulses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">get_pulses</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ESR</span><span class="p">[</span><span class="s2">&quot;read_pulse&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;ESR_results&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">read_pulse</span><span class="p">,</span> <span class="n">ESR_pulse</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">read_pulses</span><span class="p">,</span> <span class="n">ESR_pulses</span><span class="p">):</span>
            <span class="n">read_traces</span> <span class="o">=</span> <span class="n">traces</span><span class="p">[</span><span class="n">read_pulse</span><span class="o">.</span><span class="n">full_name</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">]</span>
            <span class="n">ESR_results</span> <span class="o">=</span> <span class="n">analysis</span><span class="o">.</span><span class="n">analyse_traces</span><span class="p">(</span>
                <span class="n">traces</span><span class="o">=</span><span class="n">read_traces</span><span class="p">,</span>
                <span class="n">sample_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">,</span>
                <span class="nb">filter</span><span class="o">=</span><span class="s1">&#39;low&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_traces</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">min_filter_proportion</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_filter_proportion</span><span class="p">,</span>
                <span class="n">threshold_voltage</span><span class="o">=</span><span class="n">threshold_voltage</span><span class="p">,</span>
                <span class="n">t_skip</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">t_skip</span><span class="p">,</span>
                <span class="n">t_read</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">t_read</span><span class="p">,</span>
                <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">)</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;ESR_results&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ESR_results</span><span class="p">)</span>

            <span class="c1"># Extract ESR pulse labels</span>
            <span class="k">if</span> <span class="n">ESR_pulse_names</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">ESR_pulse</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Ignore suffix</span>
                <span class="n">pulse_label</span> <span class="o">=</span> <span class="n">ESR_pulse</span><span class="o">.</span><span class="n">name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">suffix</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">results</span>
                              <span class="k">if</span> <span class="n">f</span><span class="s1">&#39;up_proportion_</span><span class="si">{ESR_pulse.name}</span><span class="s1">&#39;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">])</span>
                <span class="n">pulse_label</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{ESR_pulse.name}</span><span class="s1">_</span><span class="si">{suffix}</span><span class="s1">&#39;</span>

            <span class="c1"># Add up proportion and dark counts</span>
            <span class="n">results</span><span class="p">[</span><span class="n">f</span><span class="s1">&#39;up_proportion_</span><span class="si">{pulse_label}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ESR_results</span><span class="p">[</span><span class="s1">&#39;up_proportion&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">EPR</span><span class="p">[</span><span class="s1">&#39;enabled&#39;</span><span class="p">]:</span>
                <span class="c1"># Add contrast obtained by subtracting EPR dark counts</span>
                <span class="n">contrast</span> <span class="o">=</span> <span class="n">ESR_results</span><span class="p">[</span><span class="s1">&#39;up_proportion&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;dark_counts&#39;</span><span class="p">]</span>
                <span class="n">results</span><span class="p">[</span><span class="n">f</span><span class="s1">&#39;contrast_</span><span class="si">{pulse_label}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">contrast</span>
            <span class="n">results</span><span class="p">[</span><span class="n">f</span><span class="s1">&#39;num_traces_</span><span class="si">{pulse_label}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ESR_results</span><span class="p">[</span><span class="s1">&#39;num_traces&#39;</span><span class="p">]</span>

        <span class="n">voltage_differences</span> <span class="o">=</span> <span class="p">[</span><span class="n">ESR_result</span><span class="p">[</span><span class="s1">&#39;voltage_difference&#39;</span><span class="p">]</span>
                               <span class="k">for</span> <span class="n">ESR_result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;ESR_results&#39;</span><span class="p">]</span>
                               <span class="k">if</span> <span class="n">ESR_result</span><span class="p">[</span><span class="s1">&#39;voltage_difference&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">voltage_differences</span><span class="p">:</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;voltage_difference&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">voltage_differences</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;voltage_difference&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="n">results</span>
        <span class="k">return</span> <span class="n">results</span></div></div>


<span class="k">class</span> <span class="nc">T2ElectronParameter</span><span class="p">(</span><span class="n">AcquisitionParameter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parameter for measuring electron decoherence.</span>

<span class="sd">    This parameter can apply any number of refocusing pulses.</span>
<span class="sd">    It uses the `T2ElectronPulseSequence`, which will generate a pulse sequence</span>
<span class="sd">    from settings (see parameters below).</span>

<span class="sd">    In general, the pulse sequence is as follows:</span>

<span class="sd">    1. Perform any pre_pulses defined in `T2ElectronParameter.pre_pulses`.</span>
<span class="sd">    2. Perform stage pulse ``T2ElectronParameter.ESR[&#39;stage_pulse&#39;]``.</span>
<span class="sd">       By default, this is the ``plunge`` pulse.</span>
<span class="sd">    3. Perform ESR pulse within plunge pulse, the delay from start of plunge</span>
<span class="sd">       pulse is defined in ``T2ElectronParameter.ESR[&#39;pulse_delay&#39;]``.</span>
<span class="sd">    4. Perform read pulse ``T2ElectronParameter.ESR[&#39;read_pulse&#39;]``.</span>
<span class="sd">    5. Repeat steps 2 and 3 for each ESR pulse in</span>
<span class="sd">       ``T2ElectronParameter.ESR[&#39;ESR_pulses&#39;]``, which by default contains the</span>
<span class="sd">       single pulse ``T2ElectronParameter.ESR[&#39;ESR_pulse&#39;]``.</span>
<span class="sd">    6. Perform empty-plunge-read sequence (EPR), but only if</span>
<span class="sd">       ``T2ElectronParameter.EPR[&#39;enabled&#39;]`` is True.</span>
<span class="sd">       EPR pulses are defined in ``T2ElectronParameter.EPR[&#39;pulses&#39;]``.</span>
<span class="sd">    7. Perform any post_pulses defined in ``T2ElectronParameter.post_pulses``.</span>

<span class="sd">    Args:</span>
<span class="sd">        name: Parameter name</span>
<span class="sd">        **kwargs: Additional kwargs passed to `AcquisitionParameter`.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        ESR (dict): `T2ElectronPulseSequence` generator settings for ESR.</span>
<span class="sd">            Settings are: ``stage_pulse``, ``ESR_initial_pulse``,</span>
<span class="sd">            ``ESR_refocusing_pulse``, ``ESR_final_pulse``, ``read_pulse``,</span>
<span class="sd">            ``num_refocusing_pulses``, ``pre_delay``, ``inter_delay``,</span>
<span class="sd">            ``post_delay``.</span>
<span class="sd">        EPR (dict): `T2ElectronPulseSequence` generator settings for EPR.</span>
<span class="sd">            This is optional and can be toggled in ``EPR[&#39;enabled&#39;]``.</span>
<span class="sd">            If disabled, contrast is not calculated.</span>
<span class="sd">            Settings are: ``enabled``, ``pulses``.</span>
<span class="sd">        pre_pulses (List[Pulse]): Pulses to place at the start of the sequence.</span>
<span class="sd">        post_pulses (List[Pulse]): Pulses to place at the end of the sequence.</span>
<span class="sd">        pulse_sequence (PulseSequence): Pulse sequence used for acquisition.</span>
<span class="sd">        samples (int): Number of acquisition samples</span>
<span class="sd">        results (dict): Results obtained after analysis of traces.</span>
<span class="sd">        t_skip (float): initial part of read trace to ignore for measuring</span>
<span class="sd">            blips. Useful if there is a voltage spike at the start, which could</span>
<span class="sd">            otherwise be measured as a ``blip``. Retrieved from</span>
<span class="sd">            ``silq.config.properties.t_skip``.</span>
<span class="sd">        t_read (float): duration of read trace to include for measuring blips.</span>
<span class="sd">            Useful if latter half of read pulse is used for initialization.</span>
<span class="sd">            Retrieved from ``silq.config.properties.t_read``.</span>
<span class="sd">        min_filter_proportion (float): Minimum number of read traces needed in</span>
<span class="sd">            which the voltage starts low (loaded donor). Otherwise, most results</span>
<span class="sd">            are set to zero. Retrieved from</span>
<span class="sd">            ``silq.config.properties.min_filter_proportion``.</span>
<span class="sd">        traces (dict): Acquisition traces segmented by pulse and acquisition</span>
<span class="sd">            label</span>
<span class="sd">        silent (bool): Print results after acquisition</span>
<span class="sd">        continuous (bool): If True, instruments keep running after acquisition.</span>
<span class="sd">            Useful if stopping/starting instruments takes a considerable amount</span>
<span class="sd">            of time.</span>
<span class="sd">        properties_attrs (List[str]): Attributes to match with</span>
<span class="sd">            ``silq.config.properties`` See notes below for more info.</span>
<span class="sd">        save_traces (bool): Save acquired traces to disk.</span>
<span class="sd">            If the acquisition has been part of a measurement, the traces are</span>
<span class="sd">            stored in a subfolder of the corresponding data set.</span>
<span class="sd">            Otherwise, a new dataset is created.</span>
<span class="sd">        dataset (DataSet): Traces DataSet</span>
<span class="sd">        base_folder (str): Base folder in which to save traces. If not specified,</span>
<span class="sd">            and acquisition is part of a measurement, the base folder is the</span>
<span class="sd">            folder of the measurement data set. Otherwise, the base folder is</span>
<span class="sd">            the default data folder</span>
<span class="sd">        subfolder (str): Subfolder within the base folder to save traces.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Electron_T2&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span> <span class="o">=</span> <span class="n">T2ElectronPulseSequence</span><span class="p">()</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                         <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;up_proportion&#39;</span><span class="p">,</span> <span class="s1">&#39;num_traces&#39;</span><span class="p">],</span>
                         <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Up proportion&#39;</span><span class="p">,</span> <span class="s1">&#39;Number of traces&#39;</span><span class="p">],</span>
                         <span class="n">snapshot_value</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">properties_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;t_skip&#39;</span><span class="p">],</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pre_pulses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">pre_pulses</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">post_pulses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">post_pulses</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ESR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">ESR</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">EPR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">EPR</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inter_delay</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ESR</span><span class="p">[</span><span class="s1">&#39;inter_delay&#39;</span><span class="p">]</span>

    <span class="nd">@inter_delay</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">inter_delay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inter_delay</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ESR</span><span class="p">[</span><span class="s1">&#39;inter_delay&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">inter_delay</span>

    <span class="k">def</span> <span class="nf">analyse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">traces</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Analyse ESR traces.</span>

<span class="sd">        If there is only one ESR pulse, returns ``up_proportion_{pulse.name}``.</span>
<span class="sd">        If there are several ESR pulses, adds a zero-based suffix at the end for</span>
<span class="sd">        each ESR pulse. If ``ESRParameter.EPR[&#39;enabled&#39;] == True``, the results</span>
<span class="sd">        from `analyse_EPR` are also added, as well as `contrast_{pulse.name}`</span>
<span class="sd">        (plus a suffix if there are several ESR pulses).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">traces</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">traces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span>

        <span class="n">threshold_voltage</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;threshold_voltage&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">EPR</span><span class="p">[</span><span class="s1">&#39;enabled&#39;</span><span class="p">]:</span>
            <span class="c1"># Analyse EPR sequence, which also gets the dark counts</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">analysis</span><span class="o">.</span><span class="n">analyse_EPR</span><span class="p">(</span>
                <span class="n">empty_traces</span><span class="o">=</span><span class="n">traces</span><span class="p">[</span><span class="s1">&#39;empty&#39;</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">],</span>
                <span class="n">plunge_traces</span><span class="o">=</span><span class="n">traces</span><span class="p">[</span><span class="s1">&#39;plunge&#39;</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">],</span>
                <span class="n">read_traces</span><span class="o">=</span><span class="n">traces</span><span class="p">[</span><span class="s1">&#39;read_long&#39;</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">],</span>
                <span class="n">sample_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">,</span>
                <span class="n">min_filter_proportion</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_filter_proportion</span><span class="p">,</span>
                <span class="n">threshold_voltage</span><span class="o">=</span><span class="n">threshold_voltage</span><span class="p">,</span>
                <span class="n">t_skip</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">t_skip</span><span class="p">,</span> <span class="c1"># Use t_skip to keep length consistent</span>
                <span class="n">t_read</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">t_read</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">read_pulse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">get_pulse</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ESR</span><span class="p">[</span><span class="s2">&quot;read_pulse&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">read_traces</span> <span class="o">=</span> <span class="n">traces</span><span class="p">[</span><span class="n">read_pulse</span><span class="o">.</span><span class="n">full_name</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">]</span>
        <span class="n">ESR_results</span> <span class="o">=</span> <span class="n">analysis</span><span class="o">.</span><span class="n">analyse_traces</span><span class="p">(</span>
            <span class="n">traces</span><span class="o">=</span><span class="n">read_traces</span><span class="p">,</span>
            <span class="n">sample_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">,</span>
            <span class="nb">filter</span><span class="o">=</span><span class="s1">&#39;low&#39;</span><span class="p">,</span>
            <span class="n">threshold_voltage</span><span class="o">=</span><span class="n">threshold_voltage</span><span class="p">,</span>
            <span class="n">t_skip</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">t_skip</span><span class="p">,</span>
            <span class="n">t_read</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">t_read</span><span class="p">)</span>

        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;ESR_results&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ESR_results</span>
        <span class="n">results</span><span class="p">[</span><span class="n">f</span><span class="s1">&#39;up_proportion_</span><span class="si">{read_pulse.name}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ESR_results</span><span class="p">[</span><span class="s1">&#39;up_proportion&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">EPR</span><span class="p">[</span><span class="s1">&#39;enabled&#39;</span><span class="p">]:</span>
            <span class="c1"># Add contrast obtained by subtracting EPR dark counts</span>
            <span class="n">contrast</span> <span class="o">=</span> <span class="n">ESR_results</span><span class="p">[</span><span class="s1">&#39;up_proportion&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;dark_counts&#39;</span><span class="p">]</span>
            <span class="n">results</span><span class="p">[</span><span class="n">f</span><span class="s1">&#39;contrast_</span><span class="si">{read_pulse.name}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">contrast</span>

        <span class="k">return</span> <span class="n">results</span>


<div class="viewcode-block" id="NMRParameter"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.NMRParameter">[docs]</a><span class="k">class</span> <span class="nc">NMRParameter</span><span class="p">(</span><span class="n">AcquisitionParameter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Parameter for most measurements involving an NMR pulse.</span>

<span class="sd">    This parameter can apply several NMR pulses, and also measure several ESR</span>
<span class="sd">    frequencies. It uses the `NMRPulseSequence`, which will generate a pulse</span>
<span class="sd">    sequence from settings (see parameters below).</span>

<span class="sd">    In general, the pulse sequence is as follows:</span>

<span class="sd">    1. Perform any pre_pulses defined in ``NMRParameter.pre_pulses``.</span>
<span class="sd">    2. Perform NMR sequence</span>

<span class="sd">       1. Perform stage pulse ``NMRParameter.NMR[&#39;stage_pulse&#39;]``.</span>
<span class="sd">          Default is &#39;empty&#39; `DCPulse`.</span>
<span class="sd">       2. Perform NMR pulses within the stage pulse. The NMR pulses defined</span>
<span class="sd">          in ``NMRParameter.NMR[&#39;NMR_pulses&#39;]`` are applied successively.</span>
<span class="sd">          The delay after start of the stage pulse is</span>
<span class="sd">          ``NMRParameter.NMR[&#39;pre_delay&#39;]``, delays between NMR pulses is</span>
<span class="sd">          ``NMRParameter.NMR[&#39;inter_delay&#39;]``, and the delay after the final</span>
<span class="sd">          NMR pulse is ``NMRParameter.NMR[&#39;post_delay&#39;]``.</span>

<span class="sd">    3. Perform ESR sequence</span>

<span class="sd">       1. Perform stage pulse ``NMRParameter.ESR[&#39;stage_pulse&#39;]``.</span>
<span class="sd">          Default is &#39;plunge&#39; `DCPulse`.</span>
<span class="sd">       2. Perform ESR pulse within stage pulse for first pulse in</span>
<span class="sd">          ``NMRParameter.ESR[&#39;ESR_pulses&#39;]``.</span>
<span class="sd">       3. Perform ``NMRParameter.ESR[&#39;read_pulse&#39;]``, and acquire trace.</span>
<span class="sd">       4. Repeat steps 1 - 3 for each ESR pulse. The different ESR pulses</span>
<span class="sd">          usually correspond to different ESR frequencies (see</span>
<span class="sd">          `NMRParameter`.ESR_frequencies).</span>
<span class="sd">       5. Repeat steps 1 - 4 for ``NMRParameter.ESR[&#39;shots_per_frequency&#39;]``</span>
<span class="sd">          This effectively interleaves the ESR pulses, which counters effects of</span>
<span class="sd">          the nucleus flipping within an acquisition.</span>

<span class="sd">    This acquisition is repeated ``NMRParameter.samples`` times. If the nucleus</span>
<span class="sd">    is in one of the states for which an ESR frequency is on resonance, a high</span>
<span class="sd">    ``up_proportion`` is measured, while for the other frequencies a low</span>
<span class="sd">    ``up_proportion`` is measured. By looking over successive samples and</span>
<span class="sd">    measuring how often the ``up_proportions`` switch between above/below</span>
<span class="sd">    ``NMRParameter.threshold_up_proportion``, nuclear flips can be measured</span>
<span class="sd">    (see `NMRParameter.analyse` and `analyse_flips`).</span>

<span class="sd">    Args:</span>
<span class="sd">        name: Parameter name</span>
<span class="sd">        **kwargs: Additional kwargs passed to `AcquisitionParameter`</span>

<span class="sd">    Parameters:</span>
<span class="sd">        NMR (dict): `NMRPulseSequence` pulse settings for NMR. Settings are:</span>
<span class="sd">            ``stage_pulse``, ``NMR_pulse``, ``NMR_pulses``, ``pre_delay``,</span>
<span class="sd">            ``inter_delay``, ``post_delay``.</span>
<span class="sd">        ESR (dict): `NMRPulseSequence` pulse settings for ESR. Settings are:</span>
<span class="sd">            ``ESR_pulse``, ``stage_pulse``, ``ESR_pulses``, ``read_pulse``,</span>
<span class="sd">            ``pulse_delay``.</span>
<span class="sd">        EPR (dict): `PulseSequenceGenerator` settings for EPR. This is optional</span>
<span class="sd">            and can be toggled in ``EPR[&#39;enabled&#39;]``. If disabled, contrast is</span>
<span class="sd">            not calculated.</span>
<span class="sd">        pre_pulses (List[Pulse]): Pulses to place at the start of the sequence.</span>
<span class="sd">        post_pulses (List[Pulse]): Pulses to place at the end of the sequence.</span>
<span class="sd">        pulse_sequence (PulseSequence): Pulse sequence used for acquisition.</span>
<span class="sd">        ESR_frequencies (List[float]): List of ESR frequencies to use. When set,</span>
<span class="sd">            a copy of ``NMRParameter.ESR[&#39;ESR_pulse&#39;]`` is created for each</span>
<span class="sd">            frequency, and added to ``NMRParameter.ESR[&#39;ESR_pulses&#39;]``.</span>
<span class="sd">        samples (int): Number of acquisition samples</span>
<span class="sd">        results (dict): Results obtained after analysis of traces.</span>
<span class="sd">        t_skip (float): initial part of read trace to ignore for measuring</span>
<span class="sd">            blips. Useful if there is a voltage spike at the start, which could</span>
<span class="sd">            otherwise be measured as a ``blip``. Retrieved from</span>
<span class="sd">            ``silq.config.properties.t_skip``.</span>
<span class="sd">        t_read (float): duration of read trace to include for measuring blips.</span>
<span class="sd">            Useful if latter half of read pulse is used for initialization.</span>
<span class="sd">            Retrieved from ``silq.config.properties.t_read``.</span>
<span class="sd">        threshold_up_proportion (Union[float, Tuple[float, float]): threshold</span>
<span class="sd">            for up proportions needed to determine ESR pulse to be on-resonance.</span>
<span class="sd">            If tuple, first element is threshold below which ESR pulse is</span>
<span class="sd">            off-resonant, and second element is threshold above which ESR pulse</span>
<span class="sd">            is on-resonant. Useful for filtering of up proportions at boundary.</span>
<span class="sd">            Retrieved from</span>
<span class="sd">            ``silq.config.properties.threshold_up_proportion``.</span>
<span class="sd">        traces (dict): Acquisition traces segmented by pulse and acquisition</span>
<span class="sd">            label</span>
<span class="sd">        silent (bool): Print results after acquisition</span>
<span class="sd">        continuous (bool): If True, instruments keep running after acquisition.</span>
<span class="sd">            Useful if stopping/starting instruments takes a considerable amount</span>
<span class="sd">            of time.</span>
<span class="sd">        properties_attrs (List[str]): Attributes to match with</span>
<span class="sd">            ``silq.config.properties`` See notes below for more info.</span>
<span class="sd">        save_traces (bool): Save acquired traces to disk.</span>
<span class="sd">            If the acquisition has been part of a measurement, the traces are</span>
<span class="sd">            stored in a subfolder of the corresponding data set.</span>
<span class="sd">            Otherwise, a new dataset is created.</span>
<span class="sd">        dataset (DataSet): Traces DataSet</span>
<span class="sd">        base_folder (str): Base folder in which to save traces. If not specified,</span>
<span class="sd">            and acquisition is part of a measurement, the base folder is the</span>
<span class="sd">            folder of the measurement data set. Otherwise, the base folder is</span>
<span class="sd">            the default data folder</span>
<span class="sd">        subfolder (str): Subfolder within the base folder to save traces.</span>

<span class="sd">    Note:</span>
<span class="sd">        - The `NMRPulseSequence` does not have an empty-plunge-read (EPR)</span>
<span class="sd">          sequence, and therefore does not add a contrast or dark counts.</span>
<span class="sd">          Verifying that the system is in tune is therefore a little bit tricky.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;NMR&#39;</span><span class="p">,</span>
                 <span class="n">names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;flips&#39;</span><span class="p">,</span> <span class="s1">&#39;flip_probability&#39;</span><span class="p">,</span> <span class="s1">&#39;up_proportions&#39;</span><span class="p">],</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameter used to determine the Rabi frequency</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span> <span class="o">=</span> <span class="n">NMRPulseSequence</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">NMR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">NMR</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ESR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">ESR</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pre_pulses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">pulse_settings</span><span class="p">[</span><span class="s1">&#39;pre_pulses&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pre_ESR_pulses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">pulse_settings</span><span class="p">[</span><span class="s1">&#39;pre_ESR_pulses&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">post_pulses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">pulse_settings</span><span class="p">[</span><span class="s1">&#39;post_pulses&#39;</span><span class="p">]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                         <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
                         <span class="n">snapshot_value</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">properties_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;t_read&#39;</span><span class="p">,</span> <span class="s1">&#39;t_skip&#39;</span><span class="p">,</span>
                                           <span class="s1">&#39;threshold_up_proportion&#39;</span><span class="p">],</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;flips&#39;</span><span class="p">,</span> <span class="s1">&#39;flip_probability&#39;</span><span class="p">,</span> <span class="s1">&#39;up_proportions&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ESR_frequencies</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">names</span> <span class="o">+=</span> <span class="p">[</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{name}</span><span class="s1">_</span><span class="si">{k}</span><span class="s1">&#39;</span>
                              <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ESR_frequencies</span><span class="p">))]</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;combined_flips&#39;</span><span class="p">,</span> <span class="s1">&#39;combined_flip_probability&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;filtered_combined_flips&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;filtered_combined_flip_probability&#39;</span><span class="p">]</span> <span class="ow">and</span> \
                            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ESR_frequencies</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">names</span> <span class="o">+=</span> <span class="p">[</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{name}</span><span class="s1">_</span><span class="si">{k}</span><span class="s1">{k+1}&#39;</span>
                          <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ESR_frequencies</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;filtered_flips&#39;</span><span class="p">,</span> <span class="s1">&#39;filtered_flip_probability&#39;</span><span class="p">]</span> <span class="ow">and</span> \
                            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ESR_frequencies</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ESR_frequencies</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{name}</span><span class="s1">_</span><span class="si">{k}</span><span class="s1">_{k-1}</span><span class="si">{k}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ESR_frequencies</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{name}</span><span class="s1">_</span><span class="si">{k}</span><span class="s1">_</span><span class="si">{k}</span><span class="s1">{k+1}&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">names</span>

    <span class="nd">@names</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_names</span> <span class="o">=</span> <span class="n">names</span>

    <span class="nd">@property_ignore_setter</span>
    <span class="k">def</span> <span class="nf">shapes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,)</span> <span class="k">if</span> <span class="s1">&#39;up_proportions&#39;</span> <span class="ow">in</span> <span class="n">name</span> <span class="k">else</span> <span class="p">()</span>
                     <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>

    <span class="nd">@property_ignore_setter</span>
    <span class="k">def</span> <span class="nf">units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ESR_frequencies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;ESR frequencies to measure.</span>

<span class="sd">        For each ESR frequency, ``NMRParameter.ESR[&#39;shots_per_read&#39;]`` reads</span>
<span class="sd">        are performed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ESR_frequencies</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pulse</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ESR</span><span class="p">[</span><span class="s1">&#39;ESR_pulses&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pulse</span><span class="p">,</span> <span class="n">Pulse</span><span class="p">):</span>
                <span class="n">ESR_frequencies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pulse</span><span class="o">.</span><span class="n">frequency</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pulse</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">ESR_frequencies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ESR</span><span class="p">[</span><span class="n">pulse</span><span class="p">]</span><span class="o">.</span><span class="n">frequency</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pulse</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
                <span class="n">ESR_subfrequencies</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">subpulse</span> <span class="ow">in</span> <span class="n">pulse</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subpulse</span><span class="p">,</span> <span class="n">Pulse</span><span class="p">):</span>
                        <span class="n">ESR_subfrequencies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subpulse</span><span class="o">.</span><span class="n">frequency</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subpulse</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                        <span class="n">ESR_subfrequencies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ESR</span><span class="p">[</span><span class="n">subpulse</span><span class="p">]</span><span class="o">.</span><span class="n">frequency</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Subpulse type not allowed: </span><span class="si">{subpulse}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">ESR_frequencies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ESR_subfrequencies</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;pulse type not allowed: </span><span class="si">{pulse}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ESR_frequencies</span>

    <span class="nd">@ESR_frequencies</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">ESR_frequencies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ESR_frequencies</span><span class="p">:</span> <span class="n">List</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ESR_frequencies</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ESR</span><span class="p">[</span><span class="s1">&#39;ESR_pulses&#39;</span><span class="p">]),</span> \
        <span class="s1">&#39;Different number of frequencies to ESR pulses.&#39;</span>

        <span class="n">updated_ESR_pulses</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ESR_subpulses</span><span class="p">,</span> <span class="n">ESR_subfrequencies</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ESR</span><span class="p">[</span><span class="s1">&#39;ESR_pulses&#39;</span><span class="p">],</span> <span class="n">ESR_frequencies</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ESR_subpulses</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">ESR_subpulses</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ESR</span><span class="p">[</span><span class="n">ESR_subpulses</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ESR_subpulses</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
                <span class="n">ESR_subpulses</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ESR</span><span class="p">[</span><span class="n">p</span><span class="p">])</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">p</span>
                    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">ESR_subpulses</span><span class="p">]</span>

            <span class="c1"># Either both the subpulses and subfrequencies must be iterable, or neither are (XNOR)</span>
            <span class="k">assert</span> \
                <span class="p">(</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">ESR_subpulses</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">ESR_subfrequencies</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span>
                <span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                    <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">ESR_subpulses</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span>
                        <span class="n">ESR_subfrequencies</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">))</span>
                <span class="p">),</span> \
            <span class="s1">&#39;Data structures for frequencies and pulses do not have the same shape.&#39;</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ESR_subpulses</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
                <span class="n">ESR_subpulses</span> <span class="o">=</span> <span class="p">[</span><span class="n">ESR_subpulses</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ESR_subfrequencies</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
                <span class="n">ESR_subfrequencies</span> <span class="o">=</span> <span class="p">[</span><span class="n">ESR_subfrequencies</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">pulse</span><span class="p">,</span> <span class="n">frequency</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ESR_subpulses</span><span class="p">,</span>
                                        <span class="n">ESR_subfrequencies</span><span class="p">):</span>
                    <span class="n">pulse</span><span class="o">.</span><span class="n">frequency</span> <span class="o">=</span> <span class="n">frequency</span>

            <span class="n">updated_ESR_pulses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ESR_subpulses</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ESR</span><span class="p">[</span><span class="s1">&#39;ESR_pulses&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">updated_ESR_pulses</span>

<div class="viewcode-block" id="NMRParameter.analyse"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.NMRParameter.analyse">[docs]</a>    <span class="k">def</span> <span class="nf">analyse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">traces</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Analyse flipping events between nuclear states</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Dict[str, Any]): Dict containing:</span>

<span class="sd">            :results_read (dict): `analyse_traces` results for each read</span>
<span class="sd">              trace</span>
<span class="sd">            :up_proportions_{idx} (np.ndarray): Up proportions, the</span>
<span class="sd">              dimensionality being equal to ``NMRParameter.samples``.</span>
<span class="sd">              ``{idx}`` is replaced with the zero-based ESR frequency index.</span>
<span class="sd">            :Results from `analyse_flips`. These are:</span>

<span class="sd">              - flips_{idx},</span>
<span class="sd">              - flip_probability_{idx}</span>
<span class="sd">              - combined_flips_{idx1}{idx2}</span>
<span class="sd">              - combined_flip_probability_{idx1}{idx2}</span>

<span class="sd">              Additionally, each of the above results will have another result</span>
<span class="sd">              with the same name, but prepended with ``filtered_``, and appended</span>
<span class="sd">              with ``_{idx1}{idx2}`` if not already present. Here, all the</span>
<span class="sd">              values are filtered out where the corresponding pair of</span>
<span class="sd">              up_proportion samples do not have exactly one high and one low for</span>
<span class="sd">              each sample. The values that do not satisfy the filter are set to</span>
<span class="sd">              ``np.nan``.</span>

<span class="sd">              :filtered_scans_{idx1}{idx2}:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">traces</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">traces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span>

        <span class="n">results</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;results_read&#39;</span><span class="p">:</span> <span class="p">[]}</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;threshold_voltage&#39;</span><span class="p">):</span>
            <span class="n">threshold_voltage</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;threshold_voltage&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Calculate threshold voltages from combined read traces</span>
            <span class="n">high_low</span> <span class="o">=</span> <span class="n">analysis</span><span class="o">.</span><span class="n">find_high_low</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">([</span><span class="n">trace</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">pulse_name</span><span class="p">,</span> <span class="n">trace</span> <span class="ow">in</span> <span class="n">traces</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                          <span class="k">if</span> <span class="n">pulse_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;read_initialize&#39;</span><span class="p">)]))</span>
            <span class="n">threshold_voltage</span> <span class="o">=</span> <span class="n">high_low</span><span class="p">[</span><span class="s1">&#39;threshold_voltage&#39;</span><span class="p">]</span>

        <span class="c1"># Extract points per shot from a single read trace</span>
        <span class="n">single_read_traces_name</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{self.ESR[&#39;read_pulse&#39;].name}</span><span class="s2">[0]&quot;</span>
        <span class="n">single_read_traces</span> <span class="o">=</span> <span class="n">traces</span><span class="p">[</span><span class="n">single_read_traces_name</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">]</span>
        <span class="n">points_per_shot</span> <span class="o">=</span> <span class="n">single_read_traces</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">read_traces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ESR_frequencies</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">ESR</span><span class="p">[</span><span class="s1">&#39;shots_per_frequency&#39;</span><span class="p">],</span>
                                     <span class="n">points_per_shot</span><span class="p">))</span>
        <span class="n">up_proportions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ESR_frequencies</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">f_idx</span><span class="p">,</span> <span class="n">ESR_frequency</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ESR_frequencies</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">):</span>
                <span class="c1"># Create array containing all read traces</span>
                <span class="n">read_traces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ESR</span><span class="p">[</span><span class="s1">&#39;shots_per_frequency&#39;</span><span class="p">],</span> <span class="n">points_per_shot</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">shot_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ESR</span><span class="p">[</span><span class="s1">&#39;shots_per_frequency&#39;</span><span class="p">]):</span>
                    <span class="c1"># Read traces of different frequencies are interleaved</span>
                    <span class="n">traces_idx</span> <span class="o">=</span> <span class="n">f_idx</span> <span class="o">+</span> <span class="n">shot_idx</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ESR_frequencies</span><span class="p">)</span>
                    <span class="n">traces_name</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{self.ESR[&#39;read_pulse&#39;].name}</span><span class="s2">[</span><span class="si">{traces_idx}</span><span class="s2">]&quot;</span>
                    <span class="n">read_traces</span><span class="p">[</span><span class="n">shot_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">traces</span><span class="p">[</span><span class="n">traces_name</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">][</span><span class="n">sample</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">read_traces</span><span class="p">[</span><span class="n">f_idx</span><span class="p">,</span> <span class="n">sample</span><span class="p">]</span> <span class="o">=</span> <span class="n">read_traces</span>
                <span class="n">read_result</span> <span class="o">=</span> <span class="n">analysis</span><span class="o">.</span><span class="n">analyse_traces</span><span class="p">(</span>
                    <span class="n">traces</span><span class="o">=</span><span class="n">read_traces</span><span class="p">,</span>
                    <span class="n">sample_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">,</span>
                    <span class="n">t_read</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">t_read</span><span class="p">,</span>
                    <span class="n">t_skip</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">t_skip</span><span class="p">,</span>
                    <span class="n">threshold_voltage</span><span class="o">=</span><span class="n">threshold_voltage</span><span class="p">)</span>
                <span class="n">up_proportions</span><span class="p">[</span><span class="n">f_idx</span><span class="p">,</span> <span class="n">sample</span><span class="p">]</span> <span class="o">=</span> <span class="n">read_result</span><span class="p">[</span><span class="s1">&#39;up_proportion&#39;</span><span class="p">]</span>
                <span class="n">results</span><span class="p">[</span><span class="s1">&#39;results_read&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">read_result</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ESR_frequencies</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">results</span><span class="p">[</span><span class="n">f</span><span class="s1">&#39;up_proportions_</span><span class="si">{f_idx}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">up_proportions</span><span class="p">[</span><span class="n">f_idx</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">results</span><span class="p">[</span><span class="s1">&#39;up_proportions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">up_proportions</span><span class="p">[</span><span class="n">f_idx</span><span class="p">]</span>

        <span class="c1"># Add singleton dimension because analyse_flips handles 3D up_proportions</span>
        <span class="n">up_proportions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">up_proportions</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">results_flips</span> <span class="o">=</span> <span class="n">analysis</span><span class="o">.</span><span class="n">analyse_flips</span><span class="p">(</span>
            <span class="n">up_proportions_arrs</span><span class="o">=</span><span class="n">up_proportions</span><span class="p">,</span>
            <span class="n">threshold_up_proportion</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">threshold_up_proportion</span><span class="p">)</span>
        <span class="c1"># Add results, only choosing first element so its no longer an array</span>
        <span class="n">results</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">results_flips</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
        <span class="k">return</span> <span class="n">results</span></div></div>


<div class="viewcode-block" id="FlipNucleusParameter"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.FlipNucleusParameter">[docs]</a><span class="k">class</span> <span class="nc">FlipNucleusParameter</span><span class="p">(</span><span class="n">AcquisitionParameter</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;flip_nucleus&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span> <span class="o">=</span> <span class="n">NMRPulseSequence</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">NMR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">NMR</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ESR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">ESR</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pre_pulses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">pulse_settings</span><span class="p">[</span><span class="s1">&#39;pre_pulses&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">post_pulses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">pulse_settings</span><span class="p">[</span><span class="s1">&#39;post_pulses&#39;</span><span class="p">]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                         <span class="n">names</span><span class="o">=</span><span class="p">[],</span>
                         <span class="n">snapshot_value</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">wrap_set</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="FlipNucleusParameter.get_NMR_pulses"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.FlipNucleusParameter.get_NMR_pulses">[docs]</a>    <span class="k">def</span> <span class="nf">get_NMR_pulses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_state</span><span class="p">,</span> <span class="n">final_state</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;neighbour&#39;</span><span class="p">,</span> <span class="s1">&#39;full&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="s1">&#39;Mode must be either `neighbour` or `full`&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">initial_state</span> <span class="o">==</span> <span class="n">final_state</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="n">pulses_config</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;environment:pulses&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;neighbour&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">initial_state</span> <span class="o">&lt;</span> <span class="n">final_state</span><span class="p">:</span>
                <span class="n">states</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">initial_state</span><span class="p">,</span> <span class="n">final_state</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">states</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">initial_state</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">final_state</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">pulse_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="s1">&#39;NMR</span><span class="si">{state}</span><span class="s1">{state+1}_pi&#39;</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states</span><span class="p">]</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">pulse_name</span> <span class="ow">in</span> <span class="n">pulses_config</span> <span class="k">for</span> <span class="n">pulse_name</span> <span class="ow">in</span> <span class="n">pulse_names</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Not all pulses are defined in config&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;full&#39;</span><span class="p">:</span>
            <span class="n">state_sequences</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">new_state_sequences</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">initial_state</span><span class="p">):</span> <span class="mi">0</span><span class="p">}</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">new_state_sequences</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">state_sequences</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="n">new_state_sequences</span><span class="p">)</span>
                <span class="n">accessed_states</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">state_sequences</span><span class="p">)))</span>
                <span class="n">new_state_sequences</span> <span class="o">=</span> <span class="p">{}</span>

                <span class="k">for</span> <span class="n">state_sequence</span><span class="p">,</span> <span class="n">duration</span> <span class="ow">in</span> <span class="n">state_sequences</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">current_state</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">state_sequence</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">pattern</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;^NMR(</span><span class="si">{current_state}</span><span class="s1">([0-9])|([0-9])</span><span class="si">{current_state}</span><span class="s1">)_pi$&#39;</span>

                    <span class="k">for</span> <span class="n">pulse_name</span><span class="p">,</span> <span class="n">pulse_settings</span> <span class="ow">in</span> <span class="n">pulses_config</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">pulse_name</span><span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
                            <span class="k">continue</span>

                        <span class="n">next_state</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">next_state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">accessed_states</span><span class="p">:</span>
                            <span class="n">new_duration</span> <span class="o">=</span> <span class="n">duration</span> <span class="o">+</span> <span class="n">pulse_settings</span><span class="p">[</span><span class="s1">&#39;duration&#39;</span><span class="p">]</span>
                            <span class="n">new_state_sequence</span> <span class="o">=</span> <span class="n">state_sequence</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">next_state</span><span class="p">)</span>
                            <span class="n">new_state_sequences</span><span class="p">[</span><span class="n">new_state_sequence</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_duration</span>


            <span class="c1"># Update accessed states to include new states</span>
            <span class="n">state_sequences</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="n">new_state_sequences</span><span class="p">)</span>
            <span class="n">accessed_states</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">state_sequences</span><span class="p">)))</span>

            <span class="k">if</span> <span class="n">final_state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">accessed_states</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Cannot find pulse sequence to </span><span class="si">{final_state}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">valid_state_sequences</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">state_sequences</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                                         <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">final_state</span><span class="p">}</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_state_sequences</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">state_sequence</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">valid_state_sequences</span><span class="p">,</span>
                                         <span class="n">key</span><span class="o">=</span><span class="n">valid_state_sequences</span><span class="o">.</span><span class="n">get</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">state_sequence</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">valid_state_sequences</span><span class="p">))</span>

                <span class="n">pulse_names</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">state1</span><span class="p">,</span> <span class="n">state2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">state_sequence</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">state_sequence</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                    <span class="n">pulse_name</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;NMR{min(state1, state2)}{max(state1, state2)}_pi&#39;</span>
                    <span class="n">pulse_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pulse_name</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">SinePulse</span><span class="p">(</span><span class="n">pulse_name</span><span class="p">)</span> <span class="k">for</span> <span class="n">pulse_name</span> <span class="ow">in</span> <span class="n">pulse_names</span><span class="p">]</span></div>

<div class="viewcode-block" id="FlipNucleusParameter.set"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.FlipNucleusParameter.set">[docs]</a>    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_state</span><span class="p">,</span> <span class="n">final_state</span><span class="p">,</span> <span class="n">run</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">initial_state</span> <span class="o">==</span> <span class="n">final_state</span><span class="p">:</span>
            <span class="c1"># No need to perform any pulse sequence</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ESR</span><span class="p">[</span><span class="s1">&#39;ESR_pulses&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">NMR</span><span class="p">[</span><span class="s1">&#39;NMR_pulses&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_NMR_pulses</span><span class="p">(</span><span class="n">initial_state</span><span class="p">,</span> <span class="n">final_state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">run</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="n">repeat</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">layout</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">layout</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="FlipFlopParameter"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.FlipFlopParameter">[docs]</a><span class="k">class</span> <span class="nc">FlipFlopParameter</span><span class="p">(</span><span class="n">AcquisitionParameter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parameter for performing flip-flopping, not meant for acquiring data&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;flip_flop&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">wrap_set</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[],</span> <span class="n">shapes</span><span class="o">=</span><span class="p">(),</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span> <span class="o">=</span> <span class="n">FlipFlopPulseSequence</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ESR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">ESR</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pre_pulses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">pre_pulses</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">post_pulses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">post_pulses</span>

<div class="viewcode-block" id="FlipFlopParameter.analyse"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.FlipFlopParameter.analyse">[docs]</a>    <span class="k">def</span> <span class="nf">analyse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">traces</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="FlipFlopParameter.set"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.FlipFlopParameter.set">[docs]</a>    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frequencies</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pre_flip</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">frequencies</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ESR</span><span class="p">[</span><span class="s1">&#39;frequencies&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">frequencies</span>
        <span class="k">if</span> <span class="n">pre_flip</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ESR</span><span class="p">[</span><span class="s1">&#39;pre_flip&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pre_flip</span>

        <span class="k">if</span> <span class="n">frequencies</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">pre_flip</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">evaluate</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="BlipsParameter"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.BlipsParameter">[docs]</a><span class="k">class</span> <span class="nc">BlipsParameter</span><span class="p">(</span><span class="n">AcquisitionParameter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parameter that measures properties of blips in a trace</span>

<span class="sd">    The `PulseSequence` consists of a single read pulse.</span>
<span class="sd">    From this trace, the number of blips per second is counted, as well as the</span>
<span class="sd">    mean time in ``low`` and ``high`` voltage state.</span>
<span class="sd">    This parameter can be used in retuning sequence.</span>

<span class="sd">    Args:</span>
<span class="sd">        name: Parameter name.</span>
<span class="sd">        duration: Duration of read trace</span>
<span class="sd">        pulse_name: Name of read pulse</span>
<span class="sd">        **kwargs: Additional kwargs passed to `AcquisitionParameter`.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        threshold_voltage (float): Threshold voltage for a blip in voltage.</span>
<span class="sd">        pulse_sequence (PulseSequence): Pulse sequence used for acquisition.</span>
<span class="sd">        samples (int): Number of acquisition samples</span>
<span class="sd">        results (dict): Results obtained after analysis of traces.</span>
<span class="sd">        t_skip (float): initial part of read trace to ignore for measuring</span>
<span class="sd">            blips. Useful if there is a voltage spike at the start, which could</span>
<span class="sd">            otherwise be measured as a ``blip``. Retrieved from</span>
<span class="sd">            ``silq.config.properties.t_skip``.</span>
<span class="sd">        t_read (float): duration of read trace to include for measuring blips.</span>
<span class="sd">            Useful if latter half of read pulse is used for initialization.</span>
<span class="sd">            Retrieved from ``silq.config.properties.t_read``.</span>
<span class="sd">        min_filter_proportion (float): Minimum number of read traces needed in</span>
<span class="sd">            which the voltage starts low (loaded donor). Otherwise, most results</span>
<span class="sd">            are set to zero. Retrieved from</span>
<span class="sd">            ``silq.config.properties.min_filter_proportion``.</span>
<span class="sd">        traces (dict): Acquisition traces segmented by pulse and acquisition</span>
<span class="sd">            label</span>
<span class="sd">        silent (bool): Print results after acquisition</span>
<span class="sd">        continuous (bool): If True, instruments keep running after acquisition.</span>
<span class="sd">            Useful if stopping/starting instruments takes a considerable amount</span>
<span class="sd">            of time.</span>
<span class="sd">        properties_attrs (List[str]): Attributes to match with</span>
<span class="sd">            ``silq.config.properties`` See notes below for more info.</span>
<span class="sd">        save_traces (bool): Save acquired traces to disk.</span>
<span class="sd">            If the acquisition has been part of a measurement, the traces are</span>
<span class="sd">            stored in a subfolder of the corresponding data set.</span>
<span class="sd">            Otherwise, a new dataset is created.</span>
<span class="sd">        dataset (DataSet): Traces DataSet</span>
<span class="sd">        base_folder (str): Base folder in which to save traces. If not specified,</span>
<span class="sd">            and acquisition is part of a measurement, the base folder is the</span>
<span class="sd">            folder of the measurement data set. Otherwise, the base folder is</span>
<span class="sd">            the default data folder</span>
<span class="sd">        subfolder (str): Subfolder within the base folder to save traces.</span>


<span class="sd">    See Also:</span>
<span class="sd">        - `RetuneBlipsParameter`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;count_blips&#39;</span><span class="p">,</span>
                 <span class="n">duration</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">pulse_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;DC_trace&#39;</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_name</span> <span class="o">=</span> <span class="n">pulse_name</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span> <span class="o">=</span> <span class="n">PulseSequence</span><span class="p">([</span>
            <span class="n">DCPulse</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">pulse_name</span><span class="p">,</span> <span class="n">acquire</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)])</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                         <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;blips&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;blips_per_second&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;mean_low_blip_duration&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;mean_high_blip_duration&#39;</span><span class="p">],</span>
                         <span class="n">units</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;1/s&#39;</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">],</span>
                         <span class="n">shapes</span><span class="o">=</span><span class="p">((),</span> <span class="p">(),</span> <span class="p">(),()),</span>
                         <span class="n">snapshot_value</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">continuous</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="n">duration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold_voltage</span> <span class="o">=</span> <span class="mf">0.3</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">duration</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shorthand for read pulse duration.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_name</span><span class="p">]</span><span class="o">.</span><span class="n">duration</span>

    <span class="nd">@duration</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">duration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">duration</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_name</span><span class="p">]</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="n">duration</span>

<div class="viewcode-block" id="BlipsParameter.analyse"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.BlipsParameter.analyse">[docs]</a>    <span class="k">def</span> <span class="nf">analyse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">traces</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;`count_blips` analysis.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">traces</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">traces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span>

        <span class="k">return</span> <span class="n">analysis</span><span class="o">.</span><span class="n">count_blips</span><span class="p">(</span>
            <span class="n">traces</span><span class="o">=</span><span class="n">traces</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_name</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">],</span>
            <span class="n">t_skip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">sample_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">,</span>
            <span class="n">threshold_voltage</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">threshold_voltage</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="NeuralNetworkParameter"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.NeuralNetworkParameter">[docs]</a><span class="k">class</span> <span class="nc">NeuralNetworkParameter</span><span class="p">(</span><span class="n">AcquisitionParameter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base parameter for neural networks</span>

<span class="sd">    Todo:</span>
<span class="sd">        - Needs to be updated</span>
<span class="sd">        - Transform into a `MeasurementParameter`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_parameter</span><span class="p">,</span> <span class="n">input_names</span><span class="p">,</span> <span class="n">output_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">model_filepath</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include_target_output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Load model here because it takes quite a while to load</span>
        <span class="kn">from</span> <span class="nn">keras.models</span> <span class="k">import</span> <span class="n">load_model</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">target_parameter</span> <span class="o">=</span> <span class="n">target_parameter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_names</span> <span class="o">=</span> <span class="n">input_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_target_output</span> <span class="o">=</span> <span class="n">include_target_output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_names</span> <span class="o">=</span> <span class="n">output_names</span>

        <span class="k">if</span> <span class="n">model_filepath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">model_filepath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties_config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="n">f</span><span class="s1">&#39;</span><span class="si">{self.name}</span><span class="s1">_model_filepath&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_filepath</span> <span class="o">=</span> <span class="n">model_filepath</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_filepath</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">load_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_filepath</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;No neural network model loaded for </span><span class="si">{self}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property_ignore_setter</span>
    <span class="k">def</span> <span class="nf">pulse_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_parameter</span><span class="o">.</span><span class="n">pulse_sequence</span>

    <span class="nd">@property_ignore_setter</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_names</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_target_output</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">names</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_parameter</span><span class="o">.</span><span class="n">names</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_target_output</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">include_target_output</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">names</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_target_output</span>
        <span class="k">return</span> <span class="n">names</span>

<div class="viewcode-block" id="NeuralNetworkParameter.acquire"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.NeuralNetworkParameter.acquire">[docs]</a>    <span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">target_parameter</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_parameter</span><span class="p">()</span>
        <span class="c1"># Extract target results using input names, because target_parameter.get</span>
        <span class="c1"># may provide results in a different order</span>
        <span class="n">target_results</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">target_parameter</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                          <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_names</span><span class="p">]</span>

        <span class="c1"># Convert target results to array</span>
        <span class="n">target_results_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">target_results</span><span class="p">])</span>
        <span class="n">neural_network_results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">target_results_arr</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Convert neural network results to dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neural_network_results</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">,</span>
                                               <span class="n">neural_network_results</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">neural_network_results</span></div>

<div class="viewcode-block" id="NeuralNetworkParameter.analyse"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.NeuralNetworkParameter.analyse">[docs]</a>    <span class="k">def</span> <span class="nf">analyse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">traces</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">neural_network_results</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_target_output</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">results</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">target_parameter</span><span class="o">.</span><span class="n">results</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">include_target_output</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_target_output</span><span class="p">:</span>
                <span class="n">results</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_parameter</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">results</span></div></div>


<div class="viewcode-block" id="NeuralRetuneParameter"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.NeuralRetuneParameter">[docs]</a><span class="k">class</span> <span class="nc">NeuralRetuneParameter</span><span class="p">(</span><span class="n">NeuralNetworkParameter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parameter that uses neural network for retuning.</span>

<span class="sd">    Todo:</span>
<span class="sd">        - Needs to be updated</span>
<span class="sd">        - Transform into a `MeasurementParameter`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_parameter</span><span class="p">,</span> <span class="n">output_parameters</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_parameters</span> <span class="o">=</span> <span class="n">output_parameters</span>
        <span class="n">output_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{output_parameter.name}</span><span class="s1">_delta&#39;</span> <span class="k">for</span>
                        <span class="n">output_parameter</span> <span class="ow">in</span> <span class="n">output_parameters</span><span class="p">]</span>

        <span class="n">input_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;contrast&#39;</span><span class="p">,</span> <span class="s1">&#39;dark_counts&#39;</span><span class="p">,</span> <span class="s1">&#39;high_blip_duration&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;fidelity_empty&#39;</span><span class="p">,</span> <span class="s1">&#39;voltage_difference_empty&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;low_blip_duration&#39;</span><span class="p">,</span> <span class="s1">&#39;fidelity_load&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;voltage_difference_load&#39;</span><span class="p">,</span> <span class="s1">&#39;voltage_difference_read&#39;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update</span> <span class="o">=</span> <span class="n">update</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">target_parameter</span><span class="o">=</span><span class="n">target_parameter</span><span class="p">,</span>
                         <span class="n">input_names</span><span class="o">=</span><span class="n">input_names</span><span class="p">,</span>
                         <span class="n">output_names</span><span class="o">=</span><span class="n">output_names</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property_ignore_setter</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{output_parameter.name}</span><span class="s1">_optimal&#39;</span> <span class="k">for</span>
                   <span class="n">output_parameter</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_parameters</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_target_output</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">names</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_parameter</span><span class="o">.</span><span class="n">names</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_target_output</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">include_target_output</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">names</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_target_output</span>
        <span class="k">return</span> <span class="n">names</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">base_folder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_parameter</span><span class="o">.</span><span class="n">base_folder</span>

    <span class="nd">@base_folder</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">base_folder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_folder</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_parameter</span><span class="o">.</span><span class="n">base_folder</span> <span class="o">=</span> <span class="n">base_folder</span>

<div class="viewcode-block" id="NeuralRetuneParameter.analyse"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.NeuralRetuneParameter.analyse">[docs]</a>    <span class="k">def</span> <span class="nf">analyse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">traces</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">output_parameter</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_parameters</span><span class="p">:</span>
            <span class="c1"># Get neural network otput (change in output parameter value)</span>
            <span class="n">result_name</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{output_parameter.name}</span><span class="s1">_delta&#39;</span>
            <span class="n">delta_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neural_network_results</span><span class="p">[</span><span class="n">result_name</span><span class="p">]</span>

            <span class="n">optimal_value</span> <span class="o">=</span> <span class="n">output_parameter</span><span class="p">()</span> <span class="o">+</span> <span class="n">delta_value</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">:</span>
                <span class="c1"># Update parameter to optimal value</span>
                <span class="n">output_parameter</span><span class="p">(</span><span class="n">optimal_value</span><span class="p">)</span>

            <span class="n">results</span><span class="p">[</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{output_parameter.name}</span><span class="s1">_optimal&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">optimal_value</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_target_output</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">results</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">target_parameter</span><span class="o">.</span><span class="n">results</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">include_target_output</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_target_output</span><span class="p">:</span>
                <span class="n">results</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_parameter</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">results</span></div></div>


<div class="viewcode-block" id="ESRRamseyDetuningParameter"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.ESRRamseyDetuningParameter">[docs]</a><span class="k">class</span> <span class="nc">ESRRamseyDetuningParameter</span><span class="p">(</span><span class="n">AcquisitionParameter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parameter for most pulse sequences involving electron spin resonance.</span>

<span class="sd">        This parameter can handle many of the simple pulse sequences involving ESR.</span>
<span class="sd">        It uses the `ESRPulseSequence`, which will generate a pulse sequence from</span>
<span class="sd">        settings (see parameters below).</span>

<span class="sd">        In general the pulse sequence is as follows:</span>

<span class="sd">        1. Perform any pre_pulses defined in ``ESRParameter.pre_pulses``.</span>
<span class="sd">        2. Perform stage pulse ``ESRParameter.ESR[&#39;stage_pulse&#39;]``.</span>
<span class="sd">           By default, this is the ``plunge`` pulse.</span>
<span class="sd">        3. Perform ESR pulse within plunge pulse, the delay from start of plunge</span>
<span class="sd">           pulse is defined in ``ESRParameter.ESR[&#39;pulse_delay&#39;]``.</span>
<span class="sd">        4. Perform read pulse ``ESRParameter.ESR[&#39;read_pulse&#39;]``.</span>
<span class="sd">        5. Repeat steps 2 and 3 for each ESR pulse in</span>
<span class="sd">           ``ESRParameter.ESR[&#39;ESR_pulses&#39;]``, which by default contains single</span>
<span class="sd">           pulse ``ESRParameter.ESR[&#39;ESR_pulse&#39;]``.</span>
<span class="sd">        6. Perform empty-plunge-read sequence (EPR), but only if</span>
<span class="sd">           ``ESRParameter.EPR[&#39;enabled&#39;]`` is True.</span>
<span class="sd">           EPR pulses are defined in ``ESRParameter.EPR[&#39;pulses&#39;]``.</span>
<span class="sd">        7. Perform any post_pulses defined in ``ESRParameter.post_pulses``.</span>

<span class="sd">        A shorthand for using the default ESR pulse for multiple frequencies is by</span>
<span class="sd">        setting `ESRParameter.ESR_frequencies`. Settings this will create a copy</span>
<span class="sd">        of ESRParameter.ESR[&#39;ESR_pulse&#39;] with the respective frequency.</span>

<span class="sd">        Examples:</span>
<span class="sd">            The following code measures two ESR frequencies and performs an EPR</span>
<span class="sd">            from which the contrast can be determined for each ESR frequency:</span>

<span class="sd">            &gt;&gt;&gt; ESR_parameter = ESRParameter()</span>
<span class="sd">            &gt;&gt;&gt; ESR_parameter.ESR[&#39;pulse_delay&#39;] = 5e-3</span>
<span class="sd">            &gt;&gt;&gt; ESR_parameter.ESR[&#39;stage_pulse&#39;] = DCPulse[&#39;plunge&#39;]</span>
<span class="sd">            &gt;&gt;&gt; ESR_parameter.ESR[&#39;ESR_pulse&#39;] = FrequencyRampPulse(&#39;ESR_adiabatic&#39;)</span>
<span class="sd">            &gt;&gt;&gt; ESR_parameter.ESR_frequencies = [39e9, 39.1e9]</span>
<span class="sd">            &gt;&gt;&gt; ESR_parameter.EPR[&#39;enabled&#39;] = True</span>
<span class="sd">            &gt;&gt;&gt; ESR_parameter.pulse_sequence.generate()</span>

<span class="sd">            The total pulse sequence is plunge-read-plunge-read-empty-plunge-read</span>
<span class="sd">            with an ESR pulse in the first two plunge pulses, 5 ms after the start</span>
<span class="sd">            of the plunge pulse. The ESR pulses have different frequencies.</span>

<span class="sd">        Args:</span>
<span class="sd">            name: Name of acquisition parameter</span>
<span class="sd">            **kwargs: Additional kwargs passed to `AcquisitionParameter`.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            ESR (dict): `ESRPulseSequence` generator settings for ESR. Settings are:</span>
<span class="sd">                ``stage_pulse``, ``ESR_pulse``, ``ESR_pulses``, ``pulse_delay``,</span>
<span class="sd">                ``read_pulse``.</span>
<span class="sd">            EPR (dict): `ESRPulseSequence` generator settings for EPR.</span>
<span class="sd">                This is optional and can be toggled in ``EPR[&#39;enabled&#39;]``.</span>
<span class="sd">                If disabled, contrast is not calculated.</span>
<span class="sd">                Settings are: ``enabled``, ``pulses``.</span>
<span class="sd">            pre_pulses (List[Pulse]): Pulses to place at the start of the sequence.</span>
<span class="sd">            post_pulses (List[Pulse]): Pulses to place at the end of the sequence.</span>
<span class="sd">            pulse_sequence (PulseSequence): Pulse sequence used for acquisition.</span>
<span class="sd">            samples (int): Number of acquisition samples</span>
<span class="sd">            results (dict): Results obtained after analysis of traces.</span>
<span class="sd">            t_skip (float): initial part of read trace to ignore for measuring</span>
<span class="sd">                blips. Useful if there is a voltage spike at the start, which could</span>
<span class="sd">                otherwise be measured as a ``blip``. Retrieved from</span>
<span class="sd">                ``silq.config.properties.t_skip``.</span>
<span class="sd">            t_read (float): duration of read trace to include for measuring blips.</span>
<span class="sd">                Useful if latter half of read pulse is used for initialization.</span>
<span class="sd">                Retrieved from ``silq.config.properties.t_read``.</span>
<span class="sd">            min_filter_proportion (float): Minimum number of read traces needed in</span>
<span class="sd">                which the voltage starts low (loaded donor). Otherwise, most results</span>
<span class="sd">                are set to zero. Retrieved from</span>
<span class="sd">                ``silq.config.properties.min_filter_proportion``.</span>
<span class="sd">            traces (dict): Acquisition traces segmented by pulse and acquisition</span>
<span class="sd">                label</span>
<span class="sd">            silent (bool): Print results after acquisition</span>
<span class="sd">            continuous (bool): If True, instruments keep running after acquisition.</span>
<span class="sd">                Useful if stopping/starting instruments takes a considerable amount</span>
<span class="sd">                of time.</span>
<span class="sd">            properties_attrs (List[str]): Attributes to match with</span>
<span class="sd">                ``silq.config.properties``.</span>
<span class="sd">                See notes below for more info.</span>
<span class="sd">            save_traces (bool): Save acquired traces to disk.</span>
<span class="sd">                If the acquisition has been part of a measurement, the traces are</span>
<span class="sd">                stored in a subfolder of the corresponding data set.</span>
<span class="sd">                Otherwise, a new dataset is created.</span>
<span class="sd">            dataset (DataSet): Traces DataSet</span>
<span class="sd">            base_folder (str): Base folder in which to save traces. If not specified,</span>
<span class="sd">                and acquisition is part of a measurement, the base folder is the</span>
<span class="sd">                folder of the measurement data set. Otherwise, the base folder is</span>
<span class="sd">                the default data folder</span>
<span class="sd">            subfolder (str): Subfolder within the base folder to save traces.</span>

<span class="sd">        Notes:</span>
<span class="sd">            - All pulse settings are copies of</span>
<span class="sd">              ``ESRParameter.pulse_sequence.pulse_settings``.</span>
<span class="sd">            - For given pulse settings, ``ESRParameter.pulse_sequence.generate``</span>
<span class="sd">              will recreate the pulse sequence from settings.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;ESRRamsey&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_names</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span> <span class="o">=</span> <span class="n">ESRRamseyDetuningPulseSequence</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ESR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">ESR</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">EPR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">EPR</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pre_pulses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">pre_pulses</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">post_pulses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">post_pulses</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                         <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;contrast&#39;</span><span class="p">,</span> <span class="s1">&#39;dark_counts&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;voltage_difference_read&#39;</span><span class="p">],</span>
                         <span class="n">snapshot_value</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">properties_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;t_skip&#39;</span><span class="p">,</span> <span class="s1">&#39;t_read&#39;</span><span class="p">,</span>
                                           <span class="s1">&#39;min_filter_proportion&#39;</span><span class="p">,</span>
                                           <span class="s1">&#39;filter_traces&#39;</span><span class="p">],</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">EPR</span><span class="p">[</span><span class="s1">&#39;enabled&#39;</span><span class="p">]:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Ignore all names, only add the ESR up proportions</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="s1">&#39;voltage_difference&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="p">:</span>
                <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;voltage_difference&#39;</span><span class="p">)</span>

        <span class="n">ESR_pulse_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">pulse</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">pulse</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">primary_ESR_pulses</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">pulse</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">primary_ESR_pulses</span><span class="p">:</span>
            <span class="n">pulse_name</span> <span class="o">=</span> <span class="n">pulse</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pulse</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">pulse</span><span class="o">.</span><span class="n">name</span>

            <span class="k">if</span> <span class="n">ESR_pulse_names</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">pulse_name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Ignore suffix</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">pulse_name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">suffix</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span>
                              <span class="k">if</span> <span class="n">f</span><span class="s1">&#39;up_proportion_</span><span class="si">{pulse_name}</span><span class="s1">&#39;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">])</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{pulse_name}</span><span class="s1">_</span><span class="si">{suffix}</span><span class="s1">&#39;</span>
            <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;up_proportion_</span><span class="si">{name}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">EPR</span><span class="p">[</span><span class="s1">&#39;enabled&#39;</span><span class="p">]:</span>
                <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;contrast_</span><span class="si">{name}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;num_traces_</span><span class="si">{name}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">names</span>

    <span class="nd">@names</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set all the names to return upon .get() for the EPR sequence&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span>
                       <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;contrast_&#39;</span> <span class="ow">in</span> <span class="n">name</span>
                       <span class="ow">and</span> <span class="ow">not</span> <span class="s1">&#39;up_proportion_&#39;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">]</span>

    <span class="nd">@property_ignore_setter</span>
    <span class="k">def</span> <span class="nf">shapes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">((),)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>

    <span class="nd">@property_ignore_setter</span>
    <span class="k">def</span> <span class="nf">units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ESR_frequencies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply default ESR pulse for each ESR frequency given.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">ESR_frequencies</span>

    <span class="nd">@ESR_frequencies</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">ESR_frequencies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ESR_frequencies</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">ESR_frequencies</span><span class="o">=</span><span class="n">ESR_frequencies</span><span class="p">)</span>

<div class="viewcode-block" id="ESRRamseyDetuningParameter.analyse"><a class="viewcode-back" href="../../silq.parameters.html#silq.parameters.acquisition_parameters.ESRRamseyDetuningParameter.analyse">[docs]</a>    <span class="k">def</span> <span class="nf">analyse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">traces</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Analyse ESR traces.</span>

<span class="sd">        If there is only one ESR pulse, returns ``up_proportion_{pulse.name}``.</span>
<span class="sd">        If there are several ESR pulses, adds a zero-based suffix at the end for</span>
<span class="sd">        each ESR pulse. If ``ESRParameter.EPR[&#39;enabled&#39;] == True``, the results</span>
<span class="sd">        from `analyse_EPR` are also added, as well as ``contrast_{pulse.name}``</span>
<span class="sd">        (plus a suffix if there are several ESR pulses).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">traces</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">traces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span>

        <span class="n">threshold_voltage</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;threshold_voltage&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">EPR</span><span class="p">[</span><span class="s1">&#39;enabled&#39;</span><span class="p">]:</span>
            <span class="c1"># Analyse EPR sequence, which also gets the dark counts</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">analysis</span><span class="o">.</span><span class="n">analyse_EPR</span><span class="p">(</span>
                <span class="n">empty_traces</span><span class="o">=</span><span class="n">traces</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">_EPR_pulses</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">full_name</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">],</span>
                <span class="n">plunge_traces</span><span class="o">=</span><span class="n">traces</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">_EPR_pulses</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">full_name</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">],</span>
                <span class="n">read_traces</span><span class="o">=</span><span class="n">traces</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">_EPR_pulses</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">full_name</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">],</span>
                <span class="n">sample_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">,</span>
                <span class="n">min_filter_proportion</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_filter_proportion</span><span class="p">,</span>
                <span class="n">threshold_voltage</span><span class="o">=</span><span class="n">threshold_voltage</span><span class="p">,</span>
                <span class="n">filter_traces</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_traces</span><span class="p">,</span>
                <span class="n">t_skip</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">t_skip</span><span class="p">,</span>  <span class="c1"># Use t_skip to keep length consistent</span>
                <span class="n">t_read</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">t_read</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">ESR_pulses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">primary_ESR_pulses</span>
        <span class="n">ESR_pulse_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">pulse</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">pulse</span> <span class="ow">in</span> <span class="n">ESR_pulses</span><span class="p">]</span>
        <span class="n">read_pulses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_sequence</span><span class="o">.</span><span class="n">get_pulses</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ESR</span><span class="p">[</span><span class="s2">&quot;read_pulse&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;ESR_results&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">read_pulse</span><span class="p">,</span> <span class="n">ESR_pulse</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">read_pulses</span><span class="p">,</span> <span class="n">ESR_pulses</span><span class="p">):</span>
            <span class="n">read_traces</span> <span class="o">=</span> <span class="n">traces</span><span class="p">[</span><span class="n">read_pulse</span><span class="o">.</span><span class="n">full_name</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">]</span>
            <span class="n">ESR_results</span> <span class="o">=</span> <span class="n">analysis</span><span class="o">.</span><span class="n">analyse_traces</span><span class="p">(</span>
                <span class="n">traces</span><span class="o">=</span><span class="n">read_traces</span><span class="p">,</span>
                <span class="n">sample_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">,</span>
                <span class="nb">filter</span><span class="o">=</span><span class="s1">&#39;low&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_traces</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">min_filter_proportion</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_filter_proportion</span><span class="p">,</span>
                <span class="n">threshold_voltage</span><span class="o">=</span><span class="n">threshold_voltage</span><span class="p">,</span>
                <span class="n">t_skip</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">t_skip</span><span class="p">,</span>
                <span class="n">t_read</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">t_read</span><span class="p">,</span>
                <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">)</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;ESR_results&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ESR_results</span><span class="p">)</span>

            <span class="c1"># Extract ESR pulse labels</span>
            <span class="k">if</span> <span class="n">ESR_pulse_names</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">ESR_pulse</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Ignore suffix</span>
                <span class="n">pulse_label</span> <span class="o">=</span> <span class="n">ESR_pulse</span><span class="o">.</span><span class="n">name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">suffix</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">results</span>
                              <span class="k">if</span> <span class="n">f</span><span class="s1">&#39;up_proportion_</span><span class="si">{ESR_pulse.name}</span><span class="s1">&#39;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">])</span>
                <span class="n">pulse_label</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{ESR_pulse.name}</span><span class="s1">_</span><span class="si">{suffix}</span><span class="s1">&#39;</span>

            <span class="c1"># Add up proportion and dark counts</span>
            <span class="n">results</span><span class="p">[</span><span class="n">f</span><span class="s1">&#39;up_proportion_</span><span class="si">{pulse_label}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ESR_results</span><span class="p">[</span><span class="s1">&#39;up_proportion&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">EPR</span><span class="p">[</span><span class="s1">&#39;enabled&#39;</span><span class="p">]:</span>
                <span class="c1"># Add contrast obtained by subtracting EPR dark counts</span>
                <span class="n">contrast</span> <span class="o">=</span> <span class="n">ESR_results</span><span class="p">[</span><span class="s1">&#39;up_proportion&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;dark_counts&#39;</span><span class="p">]</span>
                <span class="n">results</span><span class="p">[</span><span class="n">f</span><span class="s1">&#39;contrast_</span><span class="si">{pulse_label}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">contrast</span>
            <span class="n">results</span><span class="p">[</span><span class="n">f</span><span class="s1">&#39;num_traces_</span><span class="si">{pulse_label}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ESR_results</span><span class="p">[</span><span class="s1">&#39;num_traces&#39;</span><span class="p">]</span>

        <span class="n">voltage_differences</span> <span class="o">=</span> <span class="p">[</span><span class="n">ESR_result</span><span class="p">[</span><span class="s1">&#39;voltage_difference&#39;</span><span class="p">]</span>
                               <span class="k">for</span> <span class="n">ESR_result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;ESR_results&#39;</span><span class="p">]</span>
                               <span class="k">if</span> <span class="n">ESR_result</span><span class="p">[</span><span class="s1">&#39;voltage_difference&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">voltage_differences</span><span class="p">:</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;voltage_difference&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">voltage_differences</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;voltage_difference&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="n">results</span>
        <span class="k">return</span> <span class="n">results</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Serwan Asaad, Mark Johnson

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>